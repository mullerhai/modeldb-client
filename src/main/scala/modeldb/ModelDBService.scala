/**
 * Generated by Scrooge
 *   version: 18.10.0
 *   rev: dda071e1412b53f4bfdebc19e474f584e475d475
 *   built at: 20181018-174244
 */
package modeldb

import com.twitter.scrooge._
import com.twitter.io.Buf
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.TApplicationException
import scala.collection.immutable.{Map => immutable$Map, Set => immutable$Set}
import scala.collection.mutable.{
  Builder,
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}
import scala.language.higherKinds


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
trait ModelDBService[+MM[_]] extends _root_.com.twitter.finagle.thrift.ThriftService {
  
  def testConnection(): MM[Int]
  
  def storeDataFrame(df: modeldb.DataFrame, experimentRunId: Int): MM[Int]
  
  def pathForTransformer(transformerId: Int): MM[String]
  
  def storeFitEvent(fe: modeldb.FitEvent): MM[modeldb.FitEventResponse]
  
  def storeMetricEvent(me: modeldb.MetricEvent): MM[modeldb.MetricEventResponse]
  
  def getFilePath(t: modeldb.Transformer, experimentRunId: Int, filename: String): MM[String]
  
  def storeTransformEvent(te: modeldb.TransformEvent): MM[modeldb.TransformEventResponse]
  
  def storeRandomSplitEvent(rse: modeldb.RandomSplitEvent): MM[modeldb.RandomSplitEventResponse]
  
  def storePipelineEvent(pipelineEvent: modeldb.PipelineEvent): MM[modeldb.PipelineEventResponse]
  
  def storeCrossValidationEvent(cve: modeldb.CrossValidationEvent): MM[modeldb.CrossValidationEventResponse]
  
  def storeGridSearchCrossValidationEvent(gscve: modeldb.GridSearchCrossValidationEvent): MM[modeldb.GridSearchCrossValidationEventResponse]
  
  def storeAnnotationEvent(ae: modeldb.AnnotationEvent): MM[modeldb.AnnotationEventResponse]
  
  def storeProjectEvent(pr: modeldb.ProjectEvent): MM[modeldb.ProjectEventResponse]
  
  def storeExperimentEvent(er: modeldb.ExperimentEvent): MM[modeldb.ExperimentEventResponse]
  
  def storeExperimentRunEvent(er: modeldb.ExperimentRunEvent): MM[modeldb.ExperimentRunEventResponse]
  
  def storeLinearModel(modelId: Int, model: modeldb.LinearModel): MM[Boolean]
  
  def getDataFrameAncestry(dataFrameId: Int): MM[modeldb.DataFrameAncestry]
  
  def getCommonAncestor(dfId1: Int, dfId2: Int): MM[modeldb.CommonAncestor]
  
  def getCommonAncestorForModels(modelId1: Int, modelId2: Int): MM[modeldb.CommonAncestor]
  
  def getTrainingRowsCount(modelId: Int): MM[Int]
  
  def getTrainingRowsCounts(modelIds: Seq[Int] = Seq[Int]()): MM[Seq[Int]]
  
  def compareHyperparameters(modelId1: Int, modelId2: Int): MM[modeldb.CompareHyperParametersResponse]
  
  def compareFeatures(modelId1: Int, modelId2: Int): MM[modeldb.CompareFeaturesResponse]
  
  def groupByProblemType(modelIds: Seq[Int] = Seq[Int]()): MM[Map[modeldb.ProblemType, Seq[Int]]]
  
  def similarModels(modelId: Int, compMetrics: Seq[modeldb.ModelCompMetric] = Seq[modeldb.ModelCompMetric](), numModels: Int): MM[Seq[Int]]
  
  def linearModelFeatureImportances(modelId: Int): MM[Seq[String]]
  
  def compareLinearModelFeatureImportances(model1Id: Int, model2Id: Int): MM[Seq[modeldb.FeatureImportanceComparison]]
  
  def iterationsUntilConvergence(modelIds: Seq[Int] = Seq[Int](), tolerance: Double): MM[Seq[Int]]
  
  def rankModels(modelIds: Seq[Int] = Seq[Int](), metric: modeldb.ModelRankMetric): MM[Seq[Int]]
  
  def confidenceIntervals(modelId: Int, sigLevel: Double): MM[Seq[modeldb.ConfidenceInterval]]
  
  def modelsWithFeatures(featureNames: Seq[String] = Seq[String]()): MM[Seq[Int]]
  
  def modelsDerivedFromDataFrame(dfId: Int): MM[Seq[Int]]
  
  def getProjectIds(keyValuePairs: Map[String, String] = Map[String, String]()): MM[Seq[Int]]
  
  def getModelIds(keyValuePairs: Map[String, String] = Map[String, String]()): MM[Seq[Int]]
  
  def updateProject(projectId: Int, key: String, value: String): MM[Boolean]
  
  def createOrUpdateScalarField(modelId: Int, key: String, value: String, valueType: String): MM[Boolean]
  
  def createVectorField(modelId: Int, vectorName: String, vectorConfig: Map[String, String] = Map[String, String]()): MM[Boolean]
  
  def updateVectorField(modelId: Int, key: String, valueIndex: Int, value: String, valueType: String): MM[Boolean]
  
  def appendToVectorField(modelId: Int, vectorName: String, value: String, valueType: String): MM[Boolean]
  
  def getModel(modelId: Int): MM[modeldb.ModelResponse]
  
  def getRunsInExperiment(experimentId: Int): MM[Seq[modeldb.ExperimentRun]]
  
  def getRunsAndExperimentsInProject(projId: Int): MM[modeldb.ProjectExperimentsAndRuns]
  
  def getProjectOverviews(): MM[Seq[modeldb.ProjectOverviewResponse]]
  
  def getExperimentRunDetails(experimentRunId: Int): MM[modeldb.ExperimentRunDetailsResponse]
  
  def originalFeatures(modelId: Int): MM[Seq[String]]
  
  def storeTreeModel(modelId: Int, model: modeldb.TreeModel): MM[Boolean]
  
  def storePipelineTransformEvent(te: Seq[modeldb.TransformEvent] = Seq[modeldb.TransformEvent]()): MM[Seq[modeldb.TransformEventResponse]]
  
  def computeModelAncestry(modelId: Int): MM[modeldb.ModelAncestryResponse]
  
  def extractPipeline(modelId: Int): MM[modeldb.ExtractedPipelineResponse]

  /**
   * Used to close the underlying `Service`.
   * Not a user-defined API.
   */
  def asClosable: _root_.com.twitter.util.Closable = _root_.com.twitter.util.Closable.nop
}


object ModelDBService { self =>

  val annotations: immutable$Map[String, String] = immutable$Map.empty

  val methods: immutable$Set[ThriftMethod] = immutable$Set(
    self.TestConnection,
    self.StoreDataFrame,
    self.PathForTransformer,
    self.StoreFitEvent,
    self.StoreMetricEvent,
    self.GetFilePath,
    self.StoreTransformEvent,
    self.StoreRandomSplitEvent,
    self.StorePipelineEvent,
    self.StoreCrossValidationEvent,
    self.StoreGridSearchCrossValidationEvent,
    self.StoreAnnotationEvent,
    self.StoreProjectEvent,
    self.StoreExperimentEvent,
    self.StoreExperimentRunEvent,
    self.StoreLinearModel,
    self.GetDataFrameAncestry,
    self.GetCommonAncestor,
    self.GetCommonAncestorForModels,
    self.GetTrainingRowsCount,
    self.GetTrainingRowsCounts,
    self.CompareHyperparameters,
    self.CompareFeatures,
    self.GroupByProblemType,
    self.SimilarModels,
    self.LinearModelFeatureImportances,
    self.CompareLinearModelFeatureImportances,
    self.IterationsUntilConvergence,
    self.RankModels,
    self.ConfidenceIntervals,
    self.ModelsWithFeatures,
    self.ModelsDerivedFromDataFrame,
    self.GetProjectIds,
    self.GetModelIds,
    self.UpdateProject,
    self.CreateOrUpdateScalarField,
    self.CreateVectorField,
    self.UpdateVectorField,
    self.AppendToVectorField,
    self.GetModel,
    self.GetRunsInExperiment,
    self.GetRunsAndExperimentsInProject,
    self.GetProjectOverviews,
    self.GetExperimentRunDetails,
    self.OriginalFeatures,
    self.StoreTreeModel,
    self.StorePipelineTransformEvent,
    self.ComputeModelAncestry,
    self.ExtractPipeline
  )

  object TestConnection extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("testConnection_args")
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
      ): Args =
        new Args(
        )
    
      def unapply(_item: Args): Boolean = true
    
    
    
    }
    
    class Args(
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
      ) = this(
        Map.empty
      )
    
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Int
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("testConnection_result")
      val SuccessField: TField = new TField("success", TType.I32, 0)
      val SuccessFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Int] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.I32 =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Int] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Int]] = _root_.scala.Some(_item.success)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeSuccessField(success_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Int],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Int] with ThriftStruct
      with _root_.scala.Product1[Option[Int]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Int] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Int] = success
    
      def successField: Option[Int] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Int] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "testConnection"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val testConnection$args = TestConnection.Args
  type testConnection$args = TestConnection.Args

  val testConnection$result = TestConnection.Result
  type testConnection$result = TestConnection.Result

  object StoreDataFrame extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeDataFrame_args")
      val DfField: TField = new TField("df", TType.STRUCT, 1)
      val DfFieldManifest: Manifest[modeldb.DataFrame] = implicitly[Manifest[modeldb.DataFrame]]
      val ExperimentRunIdField: TField = new TField("experimentRunId", TType.I32, 2)
      val ExperimentRunIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          DfField,
          false,
          false,
          DfFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ExperimentRunIdField,
          false,
          false,
          ExperimentRunIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.df)
        buf ++= validateField(item.experimentRunId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          df =
            {
              val field = original.df
              modeldb.DataFrame.withoutPassthroughFields(field)
            },
          experimentRunId =
            {
              val field = original.experimentRunId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var df: modeldb.DataFrame = null
        var experimentRunId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    df = readDfValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'df' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    experimentRunId = readExperimentRunIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'experimentRunId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          df,
          experimentRunId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        df: modeldb.DataFrame,
        experimentRunId: Int
      ): Args =
        new Args(
          df,
          experimentRunId
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[modeldb.DataFrame, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readDfValue(_iprot: TProtocol): modeldb.DataFrame = {
        modeldb.DataFrame.decode(_iprot)
      }
    
      @inline private def writeDfField(df_item: modeldb.DataFrame, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(DfField)
        writeDfValue(df_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeDfValue(df_item: modeldb.DataFrame, _oprot: TProtocol): Unit = {
        df_item.write(_oprot)
      }
    
      @inline private[modeldb] def readExperimentRunIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeExperimentRunIdField(experimentRunId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ExperimentRunIdField)
        writeExperimentRunIdValue(experimentRunId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeExperimentRunIdValue(experimentRunId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(experimentRunId_item)
      }
    
    
    }
    
    class Args(
        val df: modeldb.DataFrame,
        val experimentRunId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[modeldb.DataFrame, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        df: modeldb.DataFrame,
        experimentRunId: Int
      ) = this(
        df,
        experimentRunId,
        Map.empty
      )
    
      def _1: modeldb.DataFrame = df
      def _2: Int = experimentRunId
    
      def toTuple: _root_.scala.Tuple2[modeldb.DataFrame, Int] = {
        (
          df,
          experimentRunId
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (df ne null) writeDfField(df, _oprot)
        writeExperimentRunIdField(experimentRunId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        df: modeldb.DataFrame = this.df,
        experimentRunId: Int = this.experimentRunId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          df,
          experimentRunId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.df
        case 1 => this.experimentRunId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Int
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeDataFrame_result")
      val SuccessField: TField = new TField("success", TType.I32, 0)
      val SuccessFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val IerExField: TField = new TField("ierEx", TType.STRUCT, 1)
      val IerExFieldManifest: Manifest[modeldb.InvalidExperimentRunException] = implicitly[Manifest[modeldb.InvalidExperimentRunException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IerExField,
          true,
          false,
          IerExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.ierEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          ierEx =
            {
              val field = original.ierEx
              field.map { field =>
                modeldb.InvalidExperimentRunException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Int] = _root_.scala.None
        var ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.I32 =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ierEx = _root_.scala.Some(readIerExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ierEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          ierEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Int] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          ierEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[Int], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeSuccessField(success_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(success_item)
      }
    
      @inline private[modeldb] def readIerExValue(_iprot: TProtocol): modeldb.InvalidExperimentRunException = {
        modeldb.InvalidExperimentRunException.decode(_iprot)
      }
    
      @inline private def writeIerExField(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IerExField)
        writeIerExValue(ierEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIerExValue(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        ierEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Int],
        val ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Int] with ThriftStruct
      with _root_.scala.Product3[Option[Int], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Int] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        ierEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Int] = success
      def _2: _root_.scala.Option[modeldb.InvalidExperimentRunException] = ierEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[Int], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          ierEx,
          svEx
        )
      }
    
      def successField: Option[Int] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(ierEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (ierEx.isDefined) writeIerExField(ierEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Int] = this.success,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = this.ierEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          ierEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.ierEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storeDataFrame"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeDataFrame$args = StoreDataFrame.Args
  type storeDataFrame$args = StoreDataFrame.Args

  val storeDataFrame$result = StoreDataFrame.Result
  type storeDataFrame$result = StoreDataFrame.Result

  object PathForTransformer extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("pathForTransformer_args")
      val TransformerIdField: TField = new TField("transformerId", TType.I32, 1)
      val TransformerIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          TransformerIdField,
          false,
          false,
          TransformerIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.transformerId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          transformerId =
            {
              val field = original.transformerId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var transformerId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    transformerId = readTransformerIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'transformerId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          transformerId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        transformerId: Int
      ): Args =
        new Args(
          transformerId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.transformerId)
    
    
      @inline private[modeldb] def readTransformerIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeTransformerIdField(transformerId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(TransformerIdField)
        writeTransformerIdValue(transformerId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeTransformerIdValue(transformerId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(transformerId_item)
      }
    
    
    }
    
    class Args(
        val transformerId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        transformerId: Int
      ) = this(
        transformerId,
        Map.empty
      )
    
      def _1: Int = transformerId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeTransformerIdField(transformerId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        transformerId: Int = this.transformerId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          transformerId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.transformerId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = String
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("pathForTransformer_result")
      val SuccessField: TField = new TField("success", TType.STRING, 0)
      val SuccessFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val EfExField: TField = new TField("efEx", TType.STRUCT, 2)
      val EfExFieldManifest: Manifest[modeldb.InvalidFieldException] = implicitly[Manifest[modeldb.InvalidFieldException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 3)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          EfExField,
          true,
          false,
          EfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.efEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          efEx =
            {
              val field = original.efEx
              field.map { field =>
                modeldb.InvalidFieldException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[String] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var efEx: _root_.scala.Option[modeldb.InvalidFieldException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRING =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    efEx = _root_.scala.Some(readEfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'efEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          efEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[String] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        efEx: _root_.scala.Option[modeldb.InvalidFieldException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          efEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple4[Option[String], Option[modeldb.ResourceNotFoundException], Option[modeldb.InvalidFieldException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSuccessField(success_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(success_item)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readEfExValue(_iprot: TProtocol): modeldb.InvalidFieldException = {
        modeldb.InvalidFieldException.decode(_iprot)
      }
    
      @inline private def writeEfExField(efEx_item: modeldb.InvalidFieldException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(EfExField)
        writeEfExValue(efEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeEfExValue(efEx_item: modeldb.InvalidFieldException, _oprot: TProtocol): Unit = {
        efEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[String],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val efEx: _root_.scala.Option[modeldb.InvalidFieldException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[String] with ThriftStruct
      with _root_.scala.Product4[Option[String], Option[modeldb.ResourceNotFoundException], Option[modeldb.InvalidFieldException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[String] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        efEx: _root_.scala.Option[modeldb.InvalidFieldException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        efEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[String] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.InvalidFieldException] = efEx
      def _4: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple4[Option[String], Option[modeldb.ResourceNotFoundException], Option[modeldb.InvalidFieldException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          efEx,
          svEx
        )
      }
    
      def successField: Option[String] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, efEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (efEx.isDefined) writeEfExField(efEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[String] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        efEx: _root_.scala.Option[modeldb.InvalidFieldException] = this.efEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          efEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.efEx
        case 3 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "pathForTransformer"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val pathForTransformer$args = PathForTransformer.Args
  type pathForTransformer$args = PathForTransformer.Args

  val pathForTransformer$result = PathForTransformer.Result
  type pathForTransformer$result = PathForTransformer.Result

  object StoreFitEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeFitEvent_args")
      val FeField: TField = new TField("fe", TType.STRUCT, 1)
      val FeFieldManifest: Manifest[modeldb.FitEvent] = implicitly[Manifest[modeldb.FitEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          FeField,
          false,
          false,
          FeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.fe)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          fe =
            {
              val field = original.fe
              modeldb.FitEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var fe: modeldb.FitEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    fe = readFeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'fe' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          fe,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        fe: modeldb.FitEvent
      ): Args =
        new Args(
          fe
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.FitEvent] = _root_.scala.Some(_item.fe)
    
    
      @inline private[modeldb] def readFeValue(_iprot: TProtocol): modeldb.FitEvent = {
        modeldb.FitEvent.decode(_iprot)
      }
    
      @inline private def writeFeField(fe_item: modeldb.FitEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(FeField)
        writeFeValue(fe_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeFeValue(fe_item: modeldb.FitEvent, _oprot: TProtocol): Unit = {
        fe_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val fe: modeldb.FitEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.FitEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        fe: modeldb.FitEvent
      ) = this(
        fe,
        Map.empty
      )
    
      def _1: modeldb.FitEvent = fe
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (fe ne null) writeFeField(fe, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        fe: modeldb.FitEvent = this.fe,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          fe,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.fe
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.FitEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeFitEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.FitEventResponse] = implicitly[Manifest[modeldb.FitEventResponse]]
      val IerExField: TField = new TField("ierEx", TType.STRUCT, 1)
      val IerExFieldManifest: Manifest[modeldb.InvalidExperimentRunException] = implicitly[Manifest[modeldb.InvalidExperimentRunException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IerExField,
          true,
          false,
          IerExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.ierEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.FitEventResponse.withoutPassthroughFields(field)
              }
            },
          ierEx =
            {
              val field = original.ierEx
              field.map { field =>
                modeldb.InvalidExperimentRunException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.FitEventResponse] = _root_.scala.None
        var ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ierEx = _root_.scala.Some(readIerExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ierEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          ierEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.FitEventResponse] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          ierEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.FitEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.FitEventResponse = {
        modeldb.FitEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.FitEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.FitEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readIerExValue(_iprot: TProtocol): modeldb.InvalidExperimentRunException = {
        modeldb.InvalidExperimentRunException.decode(_iprot)
      }
    
      @inline private def writeIerExField(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IerExField)
        writeIerExValue(ierEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIerExValue(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        ierEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.FitEventResponse],
        val ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.FitEventResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.FitEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.FitEventResponse] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        ierEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.FitEventResponse] = success
      def _2: _root_.scala.Option[modeldb.InvalidExperimentRunException] = ierEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.FitEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          ierEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.FitEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(ierEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (ierEx.isDefined) writeIerExField(ierEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.FitEventResponse] = this.success,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = this.ierEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          ierEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.ierEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storeFitEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeFitEvent$args = StoreFitEvent.Args
  type storeFitEvent$args = StoreFitEvent.Args

  val storeFitEvent$result = StoreFitEvent.Result
  type storeFitEvent$result = StoreFitEvent.Result

  object StoreMetricEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeMetricEvent_args")
      val MeField: TField = new TField("me", TType.STRUCT, 1)
      val MeFieldManifest: Manifest[modeldb.MetricEvent] = implicitly[Manifest[modeldb.MetricEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          MeField,
          false,
          false,
          MeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.me)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          me =
            {
              val field = original.me
              modeldb.MetricEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var me: modeldb.MetricEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    me = readMeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'me' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          me,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        me: modeldb.MetricEvent
      ): Args =
        new Args(
          me
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.MetricEvent] = _root_.scala.Some(_item.me)
    
    
      @inline private[modeldb] def readMeValue(_iprot: TProtocol): modeldb.MetricEvent = {
        modeldb.MetricEvent.decode(_iprot)
      }
    
      @inline private def writeMeField(me_item: modeldb.MetricEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(MeField)
        writeMeValue(me_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeMeValue(me_item: modeldb.MetricEvent, _oprot: TProtocol): Unit = {
        me_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val me: modeldb.MetricEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.MetricEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        me: modeldb.MetricEvent
      ) = this(
        me,
        Map.empty
      )
    
      def _1: modeldb.MetricEvent = me
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (me ne null) writeMeField(me, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        me: modeldb.MetricEvent = this.me,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          me,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.me
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.MetricEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeMetricEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.MetricEventResponse] = implicitly[Manifest[modeldb.MetricEventResponse]]
      val IerExField: TField = new TField("ierEx", TType.STRUCT, 1)
      val IerExFieldManifest: Manifest[modeldb.InvalidExperimentRunException] = implicitly[Manifest[modeldb.InvalidExperimentRunException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IerExField,
          true,
          false,
          IerExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.ierEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.MetricEventResponse.withoutPassthroughFields(field)
              }
            },
          ierEx =
            {
              val field = original.ierEx
              field.map { field =>
                modeldb.InvalidExperimentRunException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.MetricEventResponse] = _root_.scala.None
        var ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ierEx = _root_.scala.Some(readIerExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ierEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          ierEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.MetricEventResponse] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          ierEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.MetricEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.MetricEventResponse = {
        modeldb.MetricEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.MetricEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.MetricEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readIerExValue(_iprot: TProtocol): modeldb.InvalidExperimentRunException = {
        modeldb.InvalidExperimentRunException.decode(_iprot)
      }
    
      @inline private def writeIerExField(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IerExField)
        writeIerExValue(ierEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIerExValue(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        ierEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.MetricEventResponse],
        val ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.MetricEventResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.MetricEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.MetricEventResponse] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        ierEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.MetricEventResponse] = success
      def _2: _root_.scala.Option[modeldb.InvalidExperimentRunException] = ierEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.MetricEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          ierEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.MetricEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(ierEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (ierEx.isDefined) writeIerExField(ierEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.MetricEventResponse] = this.success,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = this.ierEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          ierEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.ierEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storeMetricEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeMetricEvent$args = StoreMetricEvent.Args
  type storeMetricEvent$args = StoreMetricEvent.Args

  val storeMetricEvent$result = StoreMetricEvent.Result
  type storeMetricEvent$result = StoreMetricEvent.Result

  object GetFilePath extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getFilePath_args")
      val TField: TField = new TField("t", TType.STRUCT, 1)
      val TFieldManifest: Manifest[modeldb.Transformer] = implicitly[Manifest[modeldb.Transformer]]
      val ExperimentRunIdField: TField = new TField("experimentRunId", TType.I32, 2)
      val ExperimentRunIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val FilenameField: TField = new TField("filename", TType.STRING, 3)
      val FilenameFieldManifest: Manifest[String] = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          TField,
          false,
          false,
          TFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ExperimentRunIdField,
          false,
          false,
          ExperimentRunIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          FilenameField,
          false,
          false,
          FilenameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.t)
        buf ++= validateField(item.experimentRunId)
        buf ++= validateField(item.filename)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          t =
            {
              val field = original.t
              modeldb.Transformer.withoutPassthroughFields(field)
            },
          experimentRunId =
            {
              val field = original.experimentRunId
              field
            },
          filename =
            {
              val field = original.filename
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var t: modeldb.Transformer = null
        var experimentRunId: Int = 0
        var filename: String = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    t = readTValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 't' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    experimentRunId = readExperimentRunIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'experimentRunId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRING =>
                    filename = readFilenameValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'filename' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          t,
          experimentRunId,
          filename,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        t: modeldb.Transformer,
        experimentRunId: Int,
        filename: String
      ): Args =
        new Args(
          t,
          experimentRunId,
          filename
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[modeldb.Transformer, Int, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readTValue(_iprot: TProtocol): modeldb.Transformer = {
        modeldb.Transformer.decode(_iprot)
      }
    
      @inline private def writeTField(t_item: modeldb.Transformer, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(TField)
        writeTValue(t_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeTValue(t_item: modeldb.Transformer, _oprot: TProtocol): Unit = {
        t_item.write(_oprot)
      }
    
      @inline private[modeldb] def readExperimentRunIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeExperimentRunIdField(experimentRunId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ExperimentRunIdField)
        writeExperimentRunIdValue(experimentRunId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeExperimentRunIdValue(experimentRunId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(experimentRunId_item)
      }
    
      @inline private[modeldb] def readFilenameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeFilenameField(filename_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(FilenameField)
        writeFilenameValue(filename_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeFilenameValue(filename_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(filename_item)
      }
    
    
    }
    
    class Args(
        val t: modeldb.Transformer,
        val experimentRunId: Int,
        val filename: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[modeldb.Transformer, Int, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        t: modeldb.Transformer,
        experimentRunId: Int,
        filename: String
      ) = this(
        t,
        experimentRunId,
        filename,
        Map.empty
      )
    
      def _1: modeldb.Transformer = t
      def _2: Int = experimentRunId
      def _3: String = filename
    
      def toTuple: _root_.scala.Tuple3[modeldb.Transformer, Int, String] = {
        (
          t,
          experimentRunId,
          filename
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (t ne null) writeTField(t, _oprot)
        writeExperimentRunIdField(experimentRunId, _oprot)
        if (filename ne null) writeFilenameField(filename, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        t: modeldb.Transformer = this.t,
        experimentRunId: Int = this.experimentRunId,
        filename: String = this.filename,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          t,
          experimentRunId,
          filename,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.t
        case 1 => this.experimentRunId
        case 2 => this.filename
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = String
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getFilePath_result")
      val SuccessField: TField = new TField("success", TType.STRING, 0)
      val SuccessFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[String] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRING =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[String] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[String], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSuccessField(success_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(success_item)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[String],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[String] with ThriftStruct
      with _root_.scala.Product3[Option[String], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[String] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[String] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[String], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[String] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[String] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "getFilePath"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getFilePath$args = GetFilePath.Args
  type getFilePath$args = GetFilePath.Args

  val getFilePath$result = GetFilePath.Result
  type getFilePath$result = GetFilePath.Result

  object StoreTransformEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeTransformEvent_args")
      val TeField: TField = new TField("te", TType.STRUCT, 1)
      val TeFieldManifest: Manifest[modeldb.TransformEvent] = implicitly[Manifest[modeldb.TransformEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          TeField,
          false,
          false,
          TeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.te)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          te =
            {
              val field = original.te
              modeldb.TransformEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var te: modeldb.TransformEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    te = readTeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'te' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          te,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        te: modeldb.TransformEvent
      ): Args =
        new Args(
          te
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.TransformEvent] = _root_.scala.Some(_item.te)
    
    
      @inline private[modeldb] def readTeValue(_iprot: TProtocol): modeldb.TransformEvent = {
        modeldb.TransformEvent.decode(_iprot)
      }
    
      @inline private def writeTeField(te_item: modeldb.TransformEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(TeField)
        writeTeValue(te_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeTeValue(te_item: modeldb.TransformEvent, _oprot: TProtocol): Unit = {
        te_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val te: modeldb.TransformEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.TransformEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        te: modeldb.TransformEvent
      ) = this(
        te,
        Map.empty
      )
    
      def _1: modeldb.TransformEvent = te
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (te ne null) writeTeField(te, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        te: modeldb.TransformEvent = this.te,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          te,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.te
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.TransformEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeTransformEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.TransformEventResponse] = implicitly[Manifest[modeldb.TransformEventResponse]]
      val IerExField: TField = new TField("ierEx", TType.STRUCT, 1)
      val IerExFieldManifest: Manifest[modeldb.InvalidExperimentRunException] = implicitly[Manifest[modeldb.InvalidExperimentRunException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IerExField,
          true,
          false,
          IerExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.ierEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.TransformEventResponse.withoutPassthroughFields(field)
              }
            },
          ierEx =
            {
              val field = original.ierEx
              field.map { field =>
                modeldb.InvalidExperimentRunException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.TransformEventResponse] = _root_.scala.None
        var ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ierEx = _root_.scala.Some(readIerExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ierEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          ierEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.TransformEventResponse] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          ierEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.TransformEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.TransformEventResponse = {
        modeldb.TransformEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.TransformEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.TransformEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readIerExValue(_iprot: TProtocol): modeldb.InvalidExperimentRunException = {
        modeldb.InvalidExperimentRunException.decode(_iprot)
      }
    
      @inline private def writeIerExField(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IerExField)
        writeIerExValue(ierEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIerExValue(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        ierEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.TransformEventResponse],
        val ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.TransformEventResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.TransformEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.TransformEventResponse] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        ierEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.TransformEventResponse] = success
      def _2: _root_.scala.Option[modeldb.InvalidExperimentRunException] = ierEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.TransformEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          ierEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.TransformEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(ierEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (ierEx.isDefined) writeIerExField(ierEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.TransformEventResponse] = this.success,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = this.ierEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          ierEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.ierEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storeTransformEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeTransformEvent$args = StoreTransformEvent.Args
  type storeTransformEvent$args = StoreTransformEvent.Args

  val storeTransformEvent$result = StoreTransformEvent.Result
  type storeTransformEvent$result = StoreTransformEvent.Result

  object StoreRandomSplitEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeRandomSplitEvent_args")
      val RseField: TField = new TField("rse", TType.STRUCT, 1)
      val RseFieldManifest: Manifest[modeldb.RandomSplitEvent] = implicitly[Manifest[modeldb.RandomSplitEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          RseField,
          false,
          false,
          RseFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.rse)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          rse =
            {
              val field = original.rse
              modeldb.RandomSplitEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var rse: modeldb.RandomSplitEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rse = readRseValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rse' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          rse,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        rse: modeldb.RandomSplitEvent
      ): Args =
        new Args(
          rse
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.RandomSplitEvent] = _root_.scala.Some(_item.rse)
    
    
      @inline private[modeldb] def readRseValue(_iprot: TProtocol): modeldb.RandomSplitEvent = {
        modeldb.RandomSplitEvent.decode(_iprot)
      }
    
      @inline private def writeRseField(rse_item: modeldb.RandomSplitEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RseField)
        writeRseValue(rse_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRseValue(rse_item: modeldb.RandomSplitEvent, _oprot: TProtocol): Unit = {
        rse_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val rse: modeldb.RandomSplitEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.RandomSplitEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        rse: modeldb.RandomSplitEvent
      ) = this(
        rse,
        Map.empty
      )
    
      def _1: modeldb.RandomSplitEvent = rse
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (rse ne null) writeRseField(rse, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        rse: modeldb.RandomSplitEvent = this.rse,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          rse,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.rse
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.RandomSplitEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeRandomSplitEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.RandomSplitEventResponse] = implicitly[Manifest[modeldb.RandomSplitEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.RandomSplitEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.RandomSplitEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.RandomSplitEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.RandomSplitEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.RandomSplitEventResponse = {
        modeldb.RandomSplitEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.RandomSplitEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.RandomSplitEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.RandomSplitEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.RandomSplitEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.RandomSplitEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.RandomSplitEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.RandomSplitEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.RandomSplitEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.RandomSplitEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.RandomSplitEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storeRandomSplitEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeRandomSplitEvent$args = StoreRandomSplitEvent.Args
  type storeRandomSplitEvent$args = StoreRandomSplitEvent.Args

  val storeRandomSplitEvent$result = StoreRandomSplitEvent.Result
  type storeRandomSplitEvent$result = StoreRandomSplitEvent.Result

  object StorePipelineEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storePipelineEvent_args")
      val PipelineEventField: TField = new TField("pipelineEvent", TType.STRUCT, 1)
      val PipelineEventFieldManifest: Manifest[modeldb.PipelineEvent] = implicitly[Manifest[modeldb.PipelineEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          PipelineEventField,
          false,
          false,
          PipelineEventFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.pipelineEvent)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          pipelineEvent =
            {
              val field = original.pipelineEvent
              modeldb.PipelineEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var pipelineEvent: modeldb.PipelineEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    pipelineEvent = readPipelineEventValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'pipelineEvent' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          pipelineEvent,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        pipelineEvent: modeldb.PipelineEvent
      ): Args =
        new Args(
          pipelineEvent
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.PipelineEvent] = _root_.scala.Some(_item.pipelineEvent)
    
    
      @inline private[modeldb] def readPipelineEventValue(_iprot: TProtocol): modeldb.PipelineEvent = {
        modeldb.PipelineEvent.decode(_iprot)
      }
    
      @inline private def writePipelineEventField(pipelineEvent_item: modeldb.PipelineEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PipelineEventField)
        writePipelineEventValue(pipelineEvent_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePipelineEventValue(pipelineEvent_item: modeldb.PipelineEvent, _oprot: TProtocol): Unit = {
        pipelineEvent_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val pipelineEvent: modeldb.PipelineEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.PipelineEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        pipelineEvent: modeldb.PipelineEvent
      ) = this(
        pipelineEvent,
        Map.empty
      )
    
      def _1: modeldb.PipelineEvent = pipelineEvent
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (pipelineEvent ne null) writePipelineEventField(pipelineEvent, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        pipelineEvent: modeldb.PipelineEvent = this.pipelineEvent,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          pipelineEvent,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.pipelineEvent
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.PipelineEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storePipelineEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.PipelineEventResponse] = implicitly[Manifest[modeldb.PipelineEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.PipelineEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.PipelineEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.PipelineEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.PipelineEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.PipelineEventResponse = {
        modeldb.PipelineEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.PipelineEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.PipelineEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.PipelineEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.PipelineEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.PipelineEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.PipelineEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.PipelineEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.PipelineEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.PipelineEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.PipelineEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storePipelineEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storePipelineEvent$args = StorePipelineEvent.Args
  type storePipelineEvent$args = StorePipelineEvent.Args

  val storePipelineEvent$result = StorePipelineEvent.Result
  type storePipelineEvent$result = StorePipelineEvent.Result

  object StoreCrossValidationEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeCrossValidationEvent_args")
      val CveField: TField = new TField("cve", TType.STRUCT, 1)
      val CveFieldManifest: Manifest[modeldb.CrossValidationEvent] = implicitly[Manifest[modeldb.CrossValidationEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          CveField,
          false,
          false,
          CveFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.cve)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          cve =
            {
              val field = original.cve
              modeldb.CrossValidationEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var cve: modeldb.CrossValidationEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    cve = readCveValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'cve' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          cve,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        cve: modeldb.CrossValidationEvent
      ): Args =
        new Args(
          cve
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.CrossValidationEvent] = _root_.scala.Some(_item.cve)
    
    
      @inline private[modeldb] def readCveValue(_iprot: TProtocol): modeldb.CrossValidationEvent = {
        modeldb.CrossValidationEvent.decode(_iprot)
      }
    
      @inline private def writeCveField(cve_item: modeldb.CrossValidationEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(CveField)
        writeCveValue(cve_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeCveValue(cve_item: modeldb.CrossValidationEvent, _oprot: TProtocol): Unit = {
        cve_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val cve: modeldb.CrossValidationEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.CrossValidationEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        cve: modeldb.CrossValidationEvent
      ) = this(
        cve,
        Map.empty
      )
    
      def _1: modeldb.CrossValidationEvent = cve
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (cve ne null) writeCveField(cve, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        cve: modeldb.CrossValidationEvent = this.cve,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          cve,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.cve
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.CrossValidationEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeCrossValidationEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.CrossValidationEventResponse] = implicitly[Manifest[modeldb.CrossValidationEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.CrossValidationEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.CrossValidationEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.CrossValidationEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.CrossValidationEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.CrossValidationEventResponse = {
        modeldb.CrossValidationEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.CrossValidationEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.CrossValidationEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.CrossValidationEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.CrossValidationEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.CrossValidationEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.CrossValidationEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.CrossValidationEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.CrossValidationEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.CrossValidationEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.CrossValidationEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storeCrossValidationEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeCrossValidationEvent$args = StoreCrossValidationEvent.Args
  type storeCrossValidationEvent$args = StoreCrossValidationEvent.Args

  val storeCrossValidationEvent$result = StoreCrossValidationEvent.Result
  type storeCrossValidationEvent$result = StoreCrossValidationEvent.Result

  object StoreGridSearchCrossValidationEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeGridSearchCrossValidationEvent_args")
      val GscveField: TField = new TField("gscve", TType.STRUCT, 1)
      val GscveFieldManifest: Manifest[modeldb.GridSearchCrossValidationEvent] = implicitly[Manifest[modeldb.GridSearchCrossValidationEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          GscveField,
          false,
          false,
          GscveFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.gscve)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          gscve =
            {
              val field = original.gscve
              modeldb.GridSearchCrossValidationEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var gscve: modeldb.GridSearchCrossValidationEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    gscve = readGscveValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'gscve' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          gscve,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        gscve: modeldb.GridSearchCrossValidationEvent
      ): Args =
        new Args(
          gscve
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.GridSearchCrossValidationEvent] = _root_.scala.Some(_item.gscve)
    
    
      @inline private[modeldb] def readGscveValue(_iprot: TProtocol): modeldb.GridSearchCrossValidationEvent = {
        modeldb.GridSearchCrossValidationEvent.decode(_iprot)
      }
    
      @inline private def writeGscveField(gscve_item: modeldb.GridSearchCrossValidationEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(GscveField)
        writeGscveValue(gscve_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeGscveValue(gscve_item: modeldb.GridSearchCrossValidationEvent, _oprot: TProtocol): Unit = {
        gscve_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val gscve: modeldb.GridSearchCrossValidationEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.GridSearchCrossValidationEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        gscve: modeldb.GridSearchCrossValidationEvent
      ) = this(
        gscve,
        Map.empty
      )
    
      def _1: modeldb.GridSearchCrossValidationEvent = gscve
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (gscve ne null) writeGscveField(gscve, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        gscve: modeldb.GridSearchCrossValidationEvent = this.gscve,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          gscve,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.gscve
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.GridSearchCrossValidationEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeGridSearchCrossValidationEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.GridSearchCrossValidationEventResponse] = implicitly[Manifest[modeldb.GridSearchCrossValidationEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.GridSearchCrossValidationEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.GridSearchCrossValidationEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.GridSearchCrossValidationEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.GridSearchCrossValidationEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.GridSearchCrossValidationEventResponse = {
        modeldb.GridSearchCrossValidationEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.GridSearchCrossValidationEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.GridSearchCrossValidationEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.GridSearchCrossValidationEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.GridSearchCrossValidationEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.GridSearchCrossValidationEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.GridSearchCrossValidationEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.GridSearchCrossValidationEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.GridSearchCrossValidationEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.GridSearchCrossValidationEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.GridSearchCrossValidationEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storeGridSearchCrossValidationEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeGridSearchCrossValidationEvent$args = StoreGridSearchCrossValidationEvent.Args
  type storeGridSearchCrossValidationEvent$args = StoreGridSearchCrossValidationEvent.Args

  val storeGridSearchCrossValidationEvent$result = StoreGridSearchCrossValidationEvent.Result
  type storeGridSearchCrossValidationEvent$result = StoreGridSearchCrossValidationEvent.Result

  object StoreAnnotationEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeAnnotationEvent_args")
      val AeField: TField = new TField("ae", TType.STRUCT, 1)
      val AeFieldManifest: Manifest[modeldb.AnnotationEvent] = implicitly[Manifest[modeldb.AnnotationEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          AeField,
          false,
          false,
          AeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.ae)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          ae =
            {
              val field = original.ae
              modeldb.AnnotationEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var ae: modeldb.AnnotationEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ae = readAeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ae' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          ae,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        ae: modeldb.AnnotationEvent
      ): Args =
        new Args(
          ae
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.AnnotationEvent] = _root_.scala.Some(_item.ae)
    
    
      @inline private[modeldb] def readAeValue(_iprot: TProtocol): modeldb.AnnotationEvent = {
        modeldb.AnnotationEvent.decode(_iprot)
      }
    
      @inline private def writeAeField(ae_item: modeldb.AnnotationEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(AeField)
        writeAeValue(ae_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeAeValue(ae_item: modeldb.AnnotationEvent, _oprot: TProtocol): Unit = {
        ae_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val ae: modeldb.AnnotationEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.AnnotationEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        ae: modeldb.AnnotationEvent
      ) = this(
        ae,
        Map.empty
      )
    
      def _1: modeldb.AnnotationEvent = ae
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (ae ne null) writeAeField(ae, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        ae: modeldb.AnnotationEvent = this.ae,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          ae,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.ae
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.AnnotationEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeAnnotationEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.AnnotationEventResponse] = implicitly[Manifest[modeldb.AnnotationEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.AnnotationEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.AnnotationEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.AnnotationEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.AnnotationEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.AnnotationEventResponse = {
        modeldb.AnnotationEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.AnnotationEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.AnnotationEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.AnnotationEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.AnnotationEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.AnnotationEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.AnnotationEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.AnnotationEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.AnnotationEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.AnnotationEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.AnnotationEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storeAnnotationEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeAnnotationEvent$args = StoreAnnotationEvent.Args
  type storeAnnotationEvent$args = StoreAnnotationEvent.Args

  val storeAnnotationEvent$result = StoreAnnotationEvent.Result
  type storeAnnotationEvent$result = StoreAnnotationEvent.Result

  object StoreProjectEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeProjectEvent_args")
      val PrField: TField = new TField("pr", TType.STRUCT, 1)
      val PrFieldManifest: Manifest[modeldb.ProjectEvent] = implicitly[Manifest[modeldb.ProjectEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          PrField,
          false,
          false,
          PrFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.pr)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          pr =
            {
              val field = original.pr
              modeldb.ProjectEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var pr: modeldb.ProjectEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    pr = readPrValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'pr' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          pr,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        pr: modeldb.ProjectEvent
      ): Args =
        new Args(
          pr
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.ProjectEvent] = _root_.scala.Some(_item.pr)
    
    
      @inline private[modeldb] def readPrValue(_iprot: TProtocol): modeldb.ProjectEvent = {
        modeldb.ProjectEvent.decode(_iprot)
      }
    
      @inline private def writePrField(pr_item: modeldb.ProjectEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PrField)
        writePrValue(pr_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePrValue(pr_item: modeldb.ProjectEvent, _oprot: TProtocol): Unit = {
        pr_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val pr: modeldb.ProjectEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.ProjectEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        pr: modeldb.ProjectEvent
      ) = this(
        pr,
        Map.empty
      )
    
      def _1: modeldb.ProjectEvent = pr
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (pr ne null) writePrField(pr, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        pr: modeldb.ProjectEvent = this.pr,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          pr,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.pr
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ProjectEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeProjectEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ProjectEventResponse] = implicitly[Manifest[modeldb.ProjectEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ProjectEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ProjectEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ProjectEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.ProjectEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ProjectEventResponse = {
        modeldb.ProjectEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ProjectEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ProjectEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ProjectEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ProjectEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.ProjectEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ProjectEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ProjectEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.ProjectEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.ProjectEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ProjectEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storeProjectEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeProjectEvent$args = StoreProjectEvent.Args
  type storeProjectEvent$args = StoreProjectEvent.Args

  val storeProjectEvent$result = StoreProjectEvent.Result
  type storeProjectEvent$result = StoreProjectEvent.Result

  object StoreExperimentEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeExperimentEvent_args")
      val ErField: TField = new TField("er", TType.STRUCT, 1)
      val ErFieldManifest: Manifest[modeldb.ExperimentEvent] = implicitly[Manifest[modeldb.ExperimentEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ErField,
          false,
          false,
          ErFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.er)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          er =
            {
              val field = original.er
              modeldb.ExperimentEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var er: modeldb.ExperimentEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    er = readErValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'er' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          er,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        er: modeldb.ExperimentEvent
      ): Args =
        new Args(
          er
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.ExperimentEvent] = _root_.scala.Some(_item.er)
    
    
      @inline private[modeldb] def readErValue(_iprot: TProtocol): modeldb.ExperimentEvent = {
        modeldb.ExperimentEvent.decode(_iprot)
      }
    
      @inline private def writeErField(er_item: modeldb.ExperimentEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ErField)
        writeErValue(er_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeErValue(er_item: modeldb.ExperimentEvent, _oprot: TProtocol): Unit = {
        er_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val er: modeldb.ExperimentEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.ExperimentEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        er: modeldb.ExperimentEvent
      ) = this(
        er,
        Map.empty
      )
    
      def _1: modeldb.ExperimentEvent = er
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (er ne null) writeErField(er, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        er: modeldb.ExperimentEvent = this.er,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          er,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.er
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ExperimentEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeExperimentEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ExperimentEventResponse] = implicitly[Manifest[modeldb.ExperimentEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ExperimentEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ExperimentEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ExperimentEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.ExperimentEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ExperimentEventResponse = {
        modeldb.ExperimentEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ExperimentEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ExperimentEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ExperimentEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ExperimentEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.ExperimentEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ExperimentEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ExperimentEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.ExperimentEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.ExperimentEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ExperimentEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storeExperimentEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeExperimentEvent$args = StoreExperimentEvent.Args
  type storeExperimentEvent$args = StoreExperimentEvent.Args

  val storeExperimentEvent$result = StoreExperimentEvent.Result
  type storeExperimentEvent$result = StoreExperimentEvent.Result

  object StoreExperimentRunEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeExperimentRunEvent_args")
      val ErField: TField = new TField("er", TType.STRUCT, 1)
      val ErFieldManifest: Manifest[modeldb.ExperimentRunEvent] = implicitly[Manifest[modeldb.ExperimentRunEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ErField,
          false,
          false,
          ErFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.er)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          er =
            {
              val field = original.er
              modeldb.ExperimentRunEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var er: modeldb.ExperimentRunEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    er = readErValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'er' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          er,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        er: modeldb.ExperimentRunEvent
      ): Args =
        new Args(
          er
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.ExperimentRunEvent] = _root_.scala.Some(_item.er)
    
    
      @inline private[modeldb] def readErValue(_iprot: TProtocol): modeldb.ExperimentRunEvent = {
        modeldb.ExperimentRunEvent.decode(_iprot)
      }
    
      @inline private def writeErField(er_item: modeldb.ExperimentRunEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ErField)
        writeErValue(er_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeErValue(er_item: modeldb.ExperimentRunEvent, _oprot: TProtocol): Unit = {
        er_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val er: modeldb.ExperimentRunEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.ExperimentRunEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        er: modeldb.ExperimentRunEvent
      ) = this(
        er,
        Map.empty
      )
    
      def _1: modeldb.ExperimentRunEvent = er
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (er ne null) writeErField(er, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        er: modeldb.ExperimentRunEvent = this.er,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          er,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.er
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ExperimentRunEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeExperimentRunEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ExperimentRunEventResponse] = implicitly[Manifest[modeldb.ExperimentRunEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ExperimentRunEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ExperimentRunEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ExperimentRunEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.ExperimentRunEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ExperimentRunEventResponse = {
        modeldb.ExperimentRunEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ExperimentRunEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ExperimentRunEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ExperimentRunEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ExperimentRunEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.ExperimentRunEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ExperimentRunEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ExperimentRunEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.ExperimentRunEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.ExperimentRunEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ExperimentRunEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storeExperimentRunEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeExperimentRunEvent$args = StoreExperimentRunEvent.Args
  type storeExperimentRunEvent$args = StoreExperimentRunEvent.Args

  val storeExperimentRunEvent$result = StoreExperimentRunEvent.Result
  type storeExperimentRunEvent$result = StoreExperimentRunEvent.Result

  object StoreLinearModel extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeLinearModel_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val ModelField: TField = new TField("model", TType.STRUCT, 2)
      val ModelFieldManifest: Manifest[modeldb.LinearModel] = implicitly[Manifest[modeldb.LinearModel]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ModelField,
          false,
          false,
          ModelFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.model)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          model =
            {
              val field = original.model
              modeldb.LinearModel.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var model: modeldb.LinearModel = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    model = readModelValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'model' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          model,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        model: modeldb.LinearModel
      ): Args =
        new Args(
          modelId,
          model
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, modeldb.LinearModel]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readModelValue(_iprot: TProtocol): modeldb.LinearModel = {
        modeldb.LinearModel.decode(_iprot)
      }
    
      @inline private def writeModelField(model_item: modeldb.LinearModel, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelField)
        writeModelValue(model_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelValue(model_item: modeldb.LinearModel, _oprot: TProtocol): Unit = {
        model_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val model: modeldb.LinearModel,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, modeldb.LinearModel]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        model: modeldb.LinearModel
      ) = this(
        modelId,
        model,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: modeldb.LinearModel = model
    
      def toTuple: _root_.scala.Tuple2[Int, modeldb.LinearModel] = {
        (
          modelId,
          model
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (model ne null) writeModelField(model, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        model: modeldb.LinearModel = this.model,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          model,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.model
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeLinearModel_result")
      val SuccessField: TField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest: Manifest[Boolean] = implicitly[Manifest[Boolean]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[Boolean], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product3[Option[Boolean], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Boolean] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[Boolean], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storeLinearModel"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeLinearModel$args = StoreLinearModel.Args
  type storeLinearModel$args = StoreLinearModel.Args

  val storeLinearModel$result = StoreLinearModel.Result
  type storeLinearModel$result = StoreLinearModel.Result

  object GetDataFrameAncestry extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getDataFrameAncestry_args")
      val DataFrameIdField: TField = new TField("dataFrameId", TType.I32, 1)
      val DataFrameIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          DataFrameIdField,
          false,
          false,
          DataFrameIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.dataFrameId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          dataFrameId =
            {
              val field = original.dataFrameId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var dataFrameId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    dataFrameId = readDataFrameIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'dataFrameId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          dataFrameId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        dataFrameId: Int
      ): Args =
        new Args(
          dataFrameId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.dataFrameId)
    
    
      @inline private[modeldb] def readDataFrameIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeDataFrameIdField(dataFrameId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(DataFrameIdField)
        writeDataFrameIdValue(dataFrameId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeDataFrameIdValue(dataFrameId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(dataFrameId_item)
      }
    
    
    }
    
    class Args(
        val dataFrameId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        dataFrameId: Int
      ) = this(
        dataFrameId,
        Map.empty
      )
    
      def _1: Int = dataFrameId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeDataFrameIdField(dataFrameId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        dataFrameId: Int = this.dataFrameId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          dataFrameId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.dataFrameId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.DataFrameAncestry
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getDataFrameAncestry_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.DataFrameAncestry] = implicitly[Manifest[modeldb.DataFrameAncestry]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.DataFrameAncestry.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.DataFrameAncestry] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.DataFrameAncestry] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.DataFrameAncestry], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.DataFrameAncestry = {
        modeldb.DataFrameAncestry.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.DataFrameAncestry, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.DataFrameAncestry, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.DataFrameAncestry],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.DataFrameAncestry] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.DataFrameAncestry], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.DataFrameAncestry] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.DataFrameAncestry] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.DataFrameAncestry], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.DataFrameAncestry] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.DataFrameAncestry] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "getDataFrameAncestry"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getDataFrameAncestry$args = GetDataFrameAncestry.Args
  type getDataFrameAncestry$args = GetDataFrameAncestry.Args

  val getDataFrameAncestry$result = GetDataFrameAncestry.Result
  type getDataFrameAncestry$result = GetDataFrameAncestry.Result

  object GetCommonAncestor extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getCommonAncestor_args")
      val DfId1Field: TField = new TField("dfId1", TType.I32, 1)
      val DfId1FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val DfId2Field: TField = new TField("dfId2", TType.I32, 2)
      val DfId2FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          DfId1Field,
          false,
          false,
          DfId1FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          DfId2Field,
          false,
          false,
          DfId2FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.dfId1)
        buf ++= validateField(item.dfId2)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          dfId1 =
            {
              val field = original.dfId1
              field
            },
          dfId2 =
            {
              val field = original.dfId2
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var dfId1: Int = 0
        var dfId2: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    dfId1 = readDfId1Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'dfId1' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    dfId2 = readDfId2Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'dfId2' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          dfId1,
          dfId2,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        dfId1: Int,
        dfId2: Int
      ): Args =
        new Args(
          dfId1,
          dfId2
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readDfId1Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeDfId1Field(dfId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(DfId1Field)
        writeDfId1Value(dfId1_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeDfId1Value(dfId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(dfId1_item)
      }
    
      @inline private[modeldb] def readDfId2Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeDfId2Field(dfId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(DfId2Field)
        writeDfId2Value(dfId2_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeDfId2Value(dfId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(dfId2_item)
      }
    
    
    }
    
    class Args(
        val dfId1: Int,
        val dfId2: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        dfId1: Int,
        dfId2: Int
      ) = this(
        dfId1,
        dfId2,
        Map.empty
      )
    
      def _1: Int = dfId1
      def _2: Int = dfId2
    
      def toTuple: _root_.scala.Tuple2[Int, Int] = {
        (
          dfId1,
          dfId2
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeDfId1Field(dfId1, _oprot)
        writeDfId2Field(dfId2, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        dfId1: Int = this.dfId1,
        dfId2: Int = this.dfId2,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          dfId1,
          dfId2,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.dfId1
        case 1 => this.dfId2
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.CommonAncestor
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getCommonAncestor_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.CommonAncestor] = implicitly[Manifest[modeldb.CommonAncestor]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.CommonAncestor.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.CommonAncestor] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.CommonAncestor] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.CommonAncestor], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.CommonAncestor = {
        modeldb.CommonAncestor.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.CommonAncestor, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.CommonAncestor, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.CommonAncestor],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.CommonAncestor] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.CommonAncestor], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.CommonAncestor] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.CommonAncestor] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.CommonAncestor], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.CommonAncestor] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.CommonAncestor] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "getCommonAncestor"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getCommonAncestor$args = GetCommonAncestor.Args
  type getCommonAncestor$args = GetCommonAncestor.Args

  val getCommonAncestor$result = GetCommonAncestor.Result
  type getCommonAncestor$result = GetCommonAncestor.Result

  object GetCommonAncestorForModels extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getCommonAncestorForModels_args")
      val ModelId1Field: TField = new TField("modelId1", TType.I32, 1)
      val ModelId1FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val ModelId2Field: TField = new TField("modelId2", TType.I32, 2)
      val ModelId2FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelId1Field,
          false,
          false,
          ModelId1FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ModelId2Field,
          false,
          false,
          ModelId2FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId1)
        buf ++= validateField(item.modelId2)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId1 =
            {
              val field = original.modelId1
              field
            },
          modelId2 =
            {
              val field = original.modelId2
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId1: Int = 0
        var modelId2: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId1 = readModelId1Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId1' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId2 = readModelId2Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId2' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId1,
          modelId2,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId1: Int,
        modelId2: Int
      ): Args =
        new Args(
          modelId1,
          modelId2
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelId1Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelId1Field(modelId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelId1Field)
        writeModelId1Value(modelId1_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelId1Value(modelId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId1_item)
      }
    
      @inline private[modeldb] def readModelId2Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelId2Field(modelId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelId2Field)
        writeModelId2Value(modelId2_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelId2Value(modelId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId2_item)
      }
    
    
    }
    
    class Args(
        val modelId1: Int,
        val modelId2: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId1: Int,
        modelId2: Int
      ) = this(
        modelId1,
        modelId2,
        Map.empty
      )
    
      def _1: Int = modelId1
      def _2: Int = modelId2
    
      def toTuple: _root_.scala.Tuple2[Int, Int] = {
        (
          modelId1,
          modelId2
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelId1Field(modelId1, _oprot)
        writeModelId2Field(modelId2, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId1: Int = this.modelId1,
        modelId2: Int = this.modelId2,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId1,
          modelId2,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId1
        case 1 => this.modelId2
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.CommonAncestor
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getCommonAncestorForModels_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.CommonAncestor] = implicitly[Manifest[modeldb.CommonAncestor]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.CommonAncestor.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.CommonAncestor] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.CommonAncestor] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.CommonAncestor], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.CommonAncestor = {
        modeldb.CommonAncestor.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.CommonAncestor, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.CommonAncestor, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.CommonAncestor],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.CommonAncestor] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.CommonAncestor], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.CommonAncestor] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.CommonAncestor] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.CommonAncestor], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.CommonAncestor] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.CommonAncestor] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "getCommonAncestorForModels"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getCommonAncestorForModels$args = GetCommonAncestorForModels.Args
  type getCommonAncestorForModels$args = GetCommonAncestorForModels.Args

  val getCommonAncestorForModels$result = GetCommonAncestorForModels.Result
  type getCommonAncestorForModels$result = GetCommonAncestorForModels.Result

  object GetTrainingRowsCount extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getTrainingRowsCount_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int
      ): Args =
        new Args(
          modelId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.modelId)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int
      ) = this(
        modelId,
        Map.empty
      )
    
      def _1: Int = modelId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Int
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getTrainingRowsCount_result")
      val SuccessField: TField = new TField("success", TType.I32, 0)
      val SuccessFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Int] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.I32 =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Int] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[Int], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeSuccessField(success_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(success_item)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Int],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Int] with ThriftStruct
      with _root_.scala.Product3[Option[Int], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Int] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Int] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[Int], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[Int] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Int] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "getTrainingRowsCount"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getTrainingRowsCount$args = GetTrainingRowsCount.Args
  type getTrainingRowsCount$args = GetTrainingRowsCount.Args

  val getTrainingRowsCount$result = GetTrainingRowsCount.Result
  type getTrainingRowsCount$result = GetTrainingRowsCount.Result

  object GetTrainingRowsCounts extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getTrainingRowsCounts_args")
      val ModelIdsField: TField = new TField("modelIds", TType.LIST, 1)
      val ModelIdsFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdsField,
          false,
          false,
          ModelIdsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelIds)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelIds =
            {
              val field = original.modelIds
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelIds: Seq[Int] = Seq[Int]()
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    modelIds = readModelIdsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'modelIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelIds,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelIds: Seq[Int] = Seq[Int]()
      ): Args =
        new Args(
          modelIds
        )
    
      def unapply(_item: Args): _root_.scala.Option[Seq[Int]] = _root_.scala.Some(_item.modelIds)
    
    
      @inline private[modeldb] def readModelIdsValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeModelIdsField(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdsField)
        writeModelIdsValue(modelIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdsValue(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, modelIds_item.size))
        modelIds_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = modelIds_item.size
            while (_i < _size) {
              val modelIds_item_element = modelIds_item(_i)
              _oprot.writeI32(modelIds_item_element)
              _i += 1
            }
          case _ =>
            modelIds_item.foreach { modelIds_item_element =>
              _oprot.writeI32(modelIds_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val modelIds: Seq[Int],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Seq[Int]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelIds: Seq[Int] = Seq[Int]()
      ) = this(
        modelIds,
        Map.empty
      )
    
      def _1: Seq[Int] = modelIds
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (modelIds ne null) writeModelIdsField(modelIds, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelIds: Seq[Int] = this.modelIds,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelIds,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelIds
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getTrainingRowsCounts_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "getTrainingRowsCounts"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getTrainingRowsCounts$args = GetTrainingRowsCounts.Args
  type getTrainingRowsCounts$args = GetTrainingRowsCounts.Args

  val getTrainingRowsCounts$result = GetTrainingRowsCounts.Result
  type getTrainingRowsCounts$result = GetTrainingRowsCounts.Result

  object CompareHyperparameters extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("compareHyperparameters_args")
      val ModelId1Field: TField = new TField("modelId1", TType.I32, 1)
      val ModelId1FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val ModelId2Field: TField = new TField("modelId2", TType.I32, 2)
      val ModelId2FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelId1Field,
          false,
          false,
          ModelId1FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ModelId2Field,
          false,
          false,
          ModelId2FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId1)
        buf ++= validateField(item.modelId2)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId1 =
            {
              val field = original.modelId1
              field
            },
          modelId2 =
            {
              val field = original.modelId2
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId1: Int = 0
        var modelId2: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId1 = readModelId1Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId1' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId2 = readModelId2Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId2' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId1,
          modelId2,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId1: Int,
        modelId2: Int
      ): Args =
        new Args(
          modelId1,
          modelId2
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelId1Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelId1Field(modelId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelId1Field)
        writeModelId1Value(modelId1_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelId1Value(modelId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId1_item)
      }
    
      @inline private[modeldb] def readModelId2Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelId2Field(modelId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelId2Field)
        writeModelId2Value(modelId2_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelId2Value(modelId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId2_item)
      }
    
    
    }
    
    class Args(
        val modelId1: Int,
        val modelId2: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId1: Int,
        modelId2: Int
      ) = this(
        modelId1,
        modelId2,
        Map.empty
      )
    
      def _1: Int = modelId1
      def _2: Int = modelId2
    
      def toTuple: _root_.scala.Tuple2[Int, Int] = {
        (
          modelId1,
          modelId2
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelId1Field(modelId1, _oprot)
        writeModelId2Field(modelId2, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId1: Int = this.modelId1,
        modelId2: Int = this.modelId2,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId1,
          modelId2,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId1
        case 1 => this.modelId2
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.CompareHyperParametersResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("compareHyperparameters_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.CompareHyperParametersResponse] = implicitly[Manifest[modeldb.CompareHyperParametersResponse]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.CompareHyperParametersResponse.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.CompareHyperParametersResponse] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.CompareHyperParametersResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.CompareHyperParametersResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.CompareHyperParametersResponse = {
        modeldb.CompareHyperParametersResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.CompareHyperParametersResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.CompareHyperParametersResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.CompareHyperParametersResponse],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.CompareHyperParametersResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.CompareHyperParametersResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.CompareHyperParametersResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.CompareHyperParametersResponse] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.CompareHyperParametersResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.CompareHyperParametersResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.CompareHyperParametersResponse] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "compareHyperparameters"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val compareHyperparameters$args = CompareHyperparameters.Args
  type compareHyperparameters$args = CompareHyperparameters.Args

  val compareHyperparameters$result = CompareHyperparameters.Result
  type compareHyperparameters$result = CompareHyperparameters.Result

  object CompareFeatures extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("compareFeatures_args")
      val ModelId1Field: TField = new TField("modelId1", TType.I32, 1)
      val ModelId1FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val ModelId2Field: TField = new TField("modelId2", TType.I32, 2)
      val ModelId2FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelId1Field,
          false,
          false,
          ModelId1FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ModelId2Field,
          false,
          false,
          ModelId2FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId1)
        buf ++= validateField(item.modelId2)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId1 =
            {
              val field = original.modelId1
              field
            },
          modelId2 =
            {
              val field = original.modelId2
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId1: Int = 0
        var modelId2: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId1 = readModelId1Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId1' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId2 = readModelId2Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId2' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId1,
          modelId2,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId1: Int,
        modelId2: Int
      ): Args =
        new Args(
          modelId1,
          modelId2
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelId1Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelId1Field(modelId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelId1Field)
        writeModelId1Value(modelId1_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelId1Value(modelId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId1_item)
      }
    
      @inline private[modeldb] def readModelId2Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelId2Field(modelId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelId2Field)
        writeModelId2Value(modelId2_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelId2Value(modelId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId2_item)
      }
    
    
    }
    
    class Args(
        val modelId1: Int,
        val modelId2: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId1: Int,
        modelId2: Int
      ) = this(
        modelId1,
        modelId2,
        Map.empty
      )
    
      def _1: Int = modelId1
      def _2: Int = modelId2
    
      def toTuple: _root_.scala.Tuple2[Int, Int] = {
        (
          modelId1,
          modelId2
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelId1Field(modelId1, _oprot)
        writeModelId2Field(modelId2, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId1: Int = this.modelId1,
        modelId2: Int = this.modelId2,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId1,
          modelId2,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId1
        case 1 => this.modelId2
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.CompareFeaturesResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("compareFeatures_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.CompareFeaturesResponse] = implicitly[Manifest[modeldb.CompareFeaturesResponse]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.CompareFeaturesResponse.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.CompareFeaturesResponse] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.CompareFeaturesResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.CompareFeaturesResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.CompareFeaturesResponse = {
        modeldb.CompareFeaturesResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.CompareFeaturesResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.CompareFeaturesResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.CompareFeaturesResponse],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.CompareFeaturesResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.CompareFeaturesResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.CompareFeaturesResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.CompareFeaturesResponse] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.CompareFeaturesResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.CompareFeaturesResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.CompareFeaturesResponse] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "compareFeatures"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val compareFeatures$args = CompareFeatures.Args
  type compareFeatures$args = CompareFeatures.Args

  val compareFeatures$result = CompareFeatures.Result
  type compareFeatures$result = CompareFeatures.Result

  object GroupByProblemType extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("groupByProblemType_args")
      val ModelIdsField: TField = new TField("modelIds", TType.LIST, 1)
      val ModelIdsFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdsField,
          false,
          false,
          ModelIdsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelIds)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelIds =
            {
              val field = original.modelIds
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelIds: Seq[Int] = Seq[Int]()
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    modelIds = readModelIdsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'modelIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelIds,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelIds: Seq[Int] = Seq[Int]()
      ): Args =
        new Args(
          modelIds
        )
    
      def unapply(_item: Args): _root_.scala.Option[Seq[Int]] = _root_.scala.Some(_item.modelIds)
    
    
      @inline private[modeldb] def readModelIdsValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeModelIdsField(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdsField)
        writeModelIdsValue(modelIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdsValue(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, modelIds_item.size))
        modelIds_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = modelIds_item.size
            while (_i < _size) {
              val modelIds_item_element = modelIds_item(_i)
              _oprot.writeI32(modelIds_item_element)
              _i += 1
            }
          case _ =>
            modelIds_item.foreach { modelIds_item_element =>
              _oprot.writeI32(modelIds_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val modelIds: Seq[Int],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Seq[Int]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelIds: Seq[Int] = Seq[Int]()
      ) = this(
        modelIds,
        Map.empty
      )
    
      def _1: Seq[Int] = modelIds
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (modelIds ne null) writeModelIdsField(modelIds, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelIds: Seq[Int] = this.modelIds,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelIds,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelIds
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Map[modeldb.ProblemType, Seq[Int]]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("groupByProblemType_result")
      val SuccessField: TField = new TField("success", TType.MAP, 0)
      val SuccessFieldManifest: Manifest[Map[modeldb.ProblemType, Seq[Int]]] = implicitly[Manifest[Map[modeldb.ProblemType, Seq[Int]]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.Some(implicitly[Manifest[modeldb.ProblemType]]),
          _root_.scala.Some(implicitly[Manifest[Seq[Int]]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { case (key, value) =>
                    val newKey = {
                    val field = key
                    field
                  }
  
  
                    val newValue = {
                    val field = value
                    field.map { field =>
                        field
                      }
                  }
  
  
                  newKey -> newValue
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Map[modeldb.ProblemType, Seq[Int]]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.MAP =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.MAP
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Map[modeldb.ProblemType, Seq[Int]]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Map[modeldb.ProblemType, Seq[Int]]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Map[modeldb.ProblemType, Seq[Int]] = {
        val _map = _iprot.readMapBegin()
        if (_map.size == 0) {
          _iprot.readMapEnd()
          Map.empty[modeldb.ProblemType, Seq[Int]]
        } else {
          val _rv = new mutable$HashMap[modeldb.ProblemType, Seq[Int]]
          var _i = 0
          while (_i < _map.size) {
            val _key = {
              modeldb.ProblemType.getOrUnknown(_iprot.readI32())
            }
            val _value = {
              val _list = _iprot.readListBegin()
              if (_list.size == 0) {
                _iprot.readListEnd()
                Nil
              } else {
                val _rv = new mutable$ArrayBuffer[Int](_list.size)
                var _i = 0
                while (_i < _list.size) {
                  _rv += {
                    _iprot.readI32()
                  }
                  _i += 1
                }
                _iprot.readListEnd()
                _rv
              }
            }
            _rv(_key) = _value
            _i += 1
          }
          _iprot.readMapEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Map[modeldb.ProblemType, Seq[Int]], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Map[modeldb.ProblemType, Seq[Int]], _oprot: TProtocol): Unit = {
        _oprot.writeMapBegin(new TMap(TType.I32, TType.LIST, success_item.size))
        success_item.foreach { case (success_item_key, success_item_value) =>
          _oprot.writeI32(success_item_key.value)
          _oprot.writeListBegin(new TList(TType.I32, success_item_value.size))
          success_item_value match {
            case _: IndexedSeq[_] =>
              var _i = 0
              val _size = success_item_value.size
              while (_i < _size) {
                val success_item_value_element = success_item_value(_i)
                _oprot.writeI32(success_item_value_element)
                _i += 1
              }
            case _ =>
              success_item_value.foreach { success_item_value_element =>
                _oprot.writeI32(success_item_value_element)
              }
          }
          _oprot.writeListEnd()
        }
        _oprot.writeMapEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Map[modeldb.ProblemType, Seq[Int]]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Map[modeldb.ProblemType, Seq[Int]]] with ThriftStruct
      with _root_.scala.Product2[Option[Map[modeldb.ProblemType, Seq[Int]]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Map[modeldb.ProblemType, Seq[Int]]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Map[modeldb.ProblemType, Seq[Int]]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Map[modeldb.ProblemType, Seq[Int]]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Map[modeldb.ProblemType, Seq[Int]]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Map[modeldb.ProblemType, Seq[Int]]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "groupByProblemType"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val groupByProblemType$args = GroupByProblemType.Args
  type groupByProblemType$args = GroupByProblemType.Args

  val groupByProblemType$result = GroupByProblemType.Result
  type groupByProblemType$result = GroupByProblemType.Result

  object SimilarModels extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("similarModels_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val CompMetricsField: TField = new TField("compMetrics", TType.LIST, 2)
      val CompMetricsFieldManifest: Manifest[Seq[modeldb.ModelCompMetric]] = implicitly[Manifest[Seq[modeldb.ModelCompMetric]]]
      val NumModelsField: TField = new TField("numModels", TType.I32, 3)
      val NumModelsFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          CompMetricsField,
          false,
          false,
          CompMetricsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[modeldb.ModelCompMetric]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          NumModelsField,
          false,
          false,
          NumModelsFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.compMetrics)
        buf ++= validateField(item.numModels)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          compMetrics =
            {
              val field = original.compMetrics
              field.map { field =>
                field
              }
            },
          numModels =
            {
              val field = original.numModels
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var compMetrics: Seq[modeldb.ModelCompMetric] = Seq[modeldb.ModelCompMetric]()
        var numModels: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.LIST =>
                    compMetrics = readCompMetricsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'compMetrics' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.I32 =>
                    numModels = readNumModelsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'numModels' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          compMetrics,
          numModels,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        compMetrics: Seq[modeldb.ModelCompMetric] = Seq[modeldb.ModelCompMetric](),
        numModels: Int
      ): Args =
        new Args(
          modelId,
          compMetrics,
          numModels
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[Int, Seq[modeldb.ModelCompMetric], Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readCompMetricsValue(_iprot: TProtocol): Seq[modeldb.ModelCompMetric] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[modeldb.ModelCompMetric](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              modeldb.ModelCompMetric.getOrUnknown(_iprot.readI32())
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeCompMetricsField(compMetrics_item: Seq[modeldb.ModelCompMetric], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(CompMetricsField)
        writeCompMetricsValue(compMetrics_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeCompMetricsValue(compMetrics_item: Seq[modeldb.ModelCompMetric], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, compMetrics_item.size))
        compMetrics_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = compMetrics_item.size
            while (_i < _size) {
              val compMetrics_item_element = compMetrics_item(_i)
              _oprot.writeI32(compMetrics_item_element.value)
              _i += 1
            }
          case _ =>
            compMetrics_item.foreach { compMetrics_item_element =>
              _oprot.writeI32(compMetrics_item_element.value)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readNumModelsValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeNumModelsField(numModels_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(NumModelsField)
        writeNumModelsValue(numModels_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeNumModelsValue(numModels_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(numModels_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val compMetrics: Seq[modeldb.ModelCompMetric],
        val numModels: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[Int, Seq[modeldb.ModelCompMetric], Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        compMetrics: Seq[modeldb.ModelCompMetric] = Seq[modeldb.ModelCompMetric](),
        numModels: Int
      ) = this(
        modelId,
        compMetrics,
        numModels,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: Seq[modeldb.ModelCompMetric] = compMetrics
      def _3: Int = numModels
    
      def toTuple: _root_.scala.Tuple3[Int, Seq[modeldb.ModelCompMetric], Int] = {
        (
          modelId,
          compMetrics,
          numModels
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (compMetrics ne null) writeCompMetricsField(compMetrics, _oprot)
        writeNumModelsField(numModels, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        compMetrics: Seq[modeldb.ModelCompMetric] = this.compMetrics,
        numModels: Int = this.numModels,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          compMetrics,
          numModels,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.compMetrics
        case 2 => this.numModels
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("similarModels_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val BrExField: TField = new TField("brEx", TType.STRUCT, 2)
      val BrExFieldManifest: Manifest[modeldb.BadRequestException] = implicitly[Manifest[modeldb.BadRequestException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 3)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          BrExField,
          true,
          false,
          BrExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.brEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          brEx =
            {
              val field = original.brEx
              field.map { field =>
                modeldb.BadRequestException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var brEx: _root_.scala.Option[modeldb.BadRequestException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    brEx = _root_.scala.Some(readBrExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'brEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          brEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        brEx: _root_.scala.Option[modeldb.BadRequestException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          brEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple4[Option[Seq[Int]], Option[modeldb.ResourceNotFoundException], Option[modeldb.BadRequestException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readBrExValue(_iprot: TProtocol): modeldb.BadRequestException = {
        modeldb.BadRequestException.decode(_iprot)
      }
    
      @inline private def writeBrExField(brEx_item: modeldb.BadRequestException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(BrExField)
        writeBrExValue(brEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeBrExValue(brEx_item: modeldb.BadRequestException, _oprot: TProtocol): Unit = {
        brEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val brEx: _root_.scala.Option[modeldb.BadRequestException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product4[Option[Seq[Int]], Option[modeldb.ResourceNotFoundException], Option[modeldb.BadRequestException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        brEx: _root_.scala.Option[modeldb.BadRequestException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        brEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.BadRequestException] = brEx
      def _4: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple4[Option[Seq[Int]], Option[modeldb.ResourceNotFoundException], Option[modeldb.BadRequestException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          brEx,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, brEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (brEx.isDefined) writeBrExField(brEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        brEx: _root_.scala.Option[modeldb.BadRequestException] = this.brEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          brEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.brEx
        case 3 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "similarModels"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val similarModels$args = SimilarModels.Args
  type similarModels$args = SimilarModels.Args

  val similarModels$result = SimilarModels.Result
  type similarModels$result = SimilarModels.Result

  object LinearModelFeatureImportances extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("linearModelFeatureImportances_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int
      ): Args =
        new Args(
          modelId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.modelId)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int
      ) = this(
        modelId,
        Map.empty
      )
    
      def _1: Int = modelId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[String]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("linearModelFeatureImportances_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[String]] = implicitly[Manifest[Seq[String]]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val IoExField: TField = new TField("ioEx", TType.STRUCT, 2)
      val IoExFieldManifest: Manifest[modeldb.IllegalOperationException] = implicitly[Manifest[modeldb.IllegalOperationException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 3)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IoExField,
          true,
          false,
          IoExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.ioEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          ioEx =
            {
              val field = original.ioEx
              field.map { field =>
                modeldb.IllegalOperationException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[String]] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ioEx = _root_.scala.Some(readIoExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ioEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          ioEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[String]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          ioEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple4[Option[Seq[String]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeString(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeString(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readIoExValue(_iprot: TProtocol): modeldb.IllegalOperationException = {
        modeldb.IllegalOperationException.decode(_iprot)
      }
    
      @inline private def writeIoExField(ioEx_item: modeldb.IllegalOperationException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IoExField)
        writeIoExValue(ioEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIoExValue(ioEx_item: modeldb.IllegalOperationException, _oprot: TProtocol): Unit = {
        ioEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[String]],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val ioEx: _root_.scala.Option[modeldb.IllegalOperationException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[String]] with ThriftStruct
      with _root_.scala.Product4[Option[Seq[String]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[String]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        ioEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[String]] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.IllegalOperationException] = ioEx
      def _4: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple4[Option[Seq[String]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          ioEx,
          svEx
        )
      }
    
      def successField: Option[Seq[String]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, ioEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (ioEx.isDefined) writeIoExField(ioEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[String]] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = this.ioEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          ioEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.ioEx
        case 3 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "linearModelFeatureImportances"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val linearModelFeatureImportances$args = LinearModelFeatureImportances.Args
  type linearModelFeatureImportances$args = LinearModelFeatureImportances.Args

  val linearModelFeatureImportances$result = LinearModelFeatureImportances.Result
  type linearModelFeatureImportances$result = LinearModelFeatureImportances.Result

  object CompareLinearModelFeatureImportances extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("compareLinearModelFeatureImportances_args")
      val Model1IdField: TField = new TField("model1Id", TType.I32, 1)
      val Model1IdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val Model2IdField: TField = new TField("model2Id", TType.I32, 2)
      val Model2IdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          Model1IdField,
          false,
          false,
          Model1IdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          Model2IdField,
          false,
          false,
          Model2IdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.model1Id)
        buf ++= validateField(item.model2Id)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          model1Id =
            {
              val field = original.model1Id
              field
            },
          model2Id =
            {
              val field = original.model2Id
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var model1Id: Int = 0
        var model2Id: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    model1Id = readModel1IdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'model1Id' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    model2Id = readModel2IdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'model2Id' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          model1Id,
          model2Id,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        model1Id: Int,
        model2Id: Int
      ): Args =
        new Args(
          model1Id,
          model2Id
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModel1IdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModel1IdField(model1Id_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(Model1IdField)
        writeModel1IdValue(model1Id_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModel1IdValue(model1Id_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(model1Id_item)
      }
    
      @inline private[modeldb] def readModel2IdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModel2IdField(model2Id_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(Model2IdField)
        writeModel2IdValue(model2Id_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModel2IdValue(model2Id_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(model2Id_item)
      }
    
    
    }
    
    class Args(
        val model1Id: Int,
        val model2Id: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        model1Id: Int,
        model2Id: Int
      ) = this(
        model1Id,
        model2Id,
        Map.empty
      )
    
      def _1: Int = model1Id
      def _2: Int = model2Id
    
      def toTuple: _root_.scala.Tuple2[Int, Int] = {
        (
          model1Id,
          model2Id
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModel1IdField(model1Id, _oprot)
        writeModel2IdField(model2Id, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        model1Id: Int = this.model1Id,
        model2Id: Int = this.model2Id,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          model1Id,
          model2Id,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.model1Id
        case 1 => this.model2Id
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[modeldb.FeatureImportanceComparison]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("compareLinearModelFeatureImportances_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[modeldb.FeatureImportanceComparison]] = implicitly[Manifest[Seq[modeldb.FeatureImportanceComparison]]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val IoExField: TField = new TField("ioEx", TType.STRUCT, 2)
      val IoExFieldManifest: Manifest[modeldb.IllegalOperationException] = implicitly[Manifest[modeldb.IllegalOperationException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 3)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[modeldb.FeatureImportanceComparison]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IoExField,
          true,
          false,
          IoExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.ioEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  modeldb.FeatureImportanceComparison.withoutPassthroughFields(field)
                }
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          ioEx =
            {
              val field = original.ioEx
              field.map { field =>
                modeldb.IllegalOperationException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[modeldb.FeatureImportanceComparison]] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ioEx = _root_.scala.Some(readIoExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ioEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          ioEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[modeldb.FeatureImportanceComparison]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          ioEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple4[Option[Seq[modeldb.FeatureImportanceComparison]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[modeldb.FeatureImportanceComparison] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[modeldb.FeatureImportanceComparison](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              modeldb.FeatureImportanceComparison.decode(_iprot)
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[modeldb.FeatureImportanceComparison], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[modeldb.FeatureImportanceComparison], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRUCT, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              success_item_element.write(_oprot)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              success_item_element.write(_oprot)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readIoExValue(_iprot: TProtocol): modeldb.IllegalOperationException = {
        modeldb.IllegalOperationException.decode(_iprot)
      }
    
      @inline private def writeIoExField(ioEx_item: modeldb.IllegalOperationException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IoExField)
        writeIoExValue(ioEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIoExValue(ioEx_item: modeldb.IllegalOperationException, _oprot: TProtocol): Unit = {
        ioEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[modeldb.FeatureImportanceComparison]],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val ioEx: _root_.scala.Option[modeldb.IllegalOperationException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[modeldb.FeatureImportanceComparison]] with ThriftStruct
      with _root_.scala.Product4[Option[Seq[modeldb.FeatureImportanceComparison]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[modeldb.FeatureImportanceComparison]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        ioEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[modeldb.FeatureImportanceComparison]] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.IllegalOperationException] = ioEx
      def _4: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple4[Option[Seq[modeldb.FeatureImportanceComparison]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          ioEx,
          svEx
        )
      }
    
      def successField: Option[Seq[modeldb.FeatureImportanceComparison]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, ioEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (ioEx.isDefined) writeIoExField(ioEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[modeldb.FeatureImportanceComparison]] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = this.ioEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          ioEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.ioEx
        case 3 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "compareLinearModelFeatureImportances"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val compareLinearModelFeatureImportances$args = CompareLinearModelFeatureImportances.Args
  type compareLinearModelFeatureImportances$args = CompareLinearModelFeatureImportances.Args

  val compareLinearModelFeatureImportances$result = CompareLinearModelFeatureImportances.Result
  type compareLinearModelFeatureImportances$result = CompareLinearModelFeatureImportances.Result

  object IterationsUntilConvergence extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("iterationsUntilConvergence_args")
      val ModelIdsField: TField = new TField("modelIds", TType.LIST, 1)
      val ModelIdsFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val ToleranceField: TField = new TField("tolerance", TType.DOUBLE, 2)
      val ToleranceFieldManifest: Manifest[Double] = implicitly[Manifest[Double]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdsField,
          false,
          false,
          ModelIdsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ToleranceField,
          false,
          false,
          ToleranceFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelIds)
        buf ++= validateField(item.tolerance)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelIds =
            {
              val field = original.modelIds
              field.map { field =>
                field
              }
            },
          tolerance =
            {
              val field = original.tolerance
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelIds: Seq[Int] = Seq[Int]()
        var tolerance: Double = 0.0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    modelIds = readModelIdsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'modelIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.DOUBLE =>
                    tolerance = readToleranceValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.DOUBLE
                    throw new TProtocolException(
                      "Received wrong type for field 'tolerance' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelIds,
          tolerance,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelIds: Seq[Int] = Seq[Int](),
        tolerance: Double
      ): Args =
        new Args(
          modelIds,
          tolerance
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Seq[Int], Double]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdsValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeModelIdsField(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdsField)
        writeModelIdsValue(modelIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdsValue(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, modelIds_item.size))
        modelIds_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = modelIds_item.size
            while (_i < _size) {
              val modelIds_item_element = modelIds_item(_i)
              _oprot.writeI32(modelIds_item_element)
              _i += 1
            }
          case _ =>
            modelIds_item.foreach { modelIds_item_element =>
              _oprot.writeI32(modelIds_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readToleranceValue(_iprot: TProtocol): Double = {
        _iprot.readDouble()
      }
    
      @inline private def writeToleranceField(tolerance_item: Double, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ToleranceField)
        writeToleranceValue(tolerance_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeToleranceValue(tolerance_item: Double, _oprot: TProtocol): Unit = {
        _oprot.writeDouble(tolerance_item)
      }
    
    
    }
    
    class Args(
        val modelIds: Seq[Int],
        val tolerance: Double,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Seq[Int], Double]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelIds: Seq[Int] = Seq[Int](),
        tolerance: Double
      ) = this(
        modelIds,
        tolerance,
        Map.empty
      )
    
      def _1: Seq[Int] = modelIds
      def _2: Double = tolerance
    
      def toTuple: _root_.scala.Tuple2[Seq[Int], Double] = {
        (
          modelIds,
          tolerance
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (modelIds ne null) writeModelIdsField(modelIds, _oprot)
        writeToleranceField(tolerance, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelIds: Seq[Int] = this.modelIds,
        tolerance: Double = this.tolerance,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelIds,
          tolerance,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelIds
        case 1 => this.tolerance
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("iterationsUntilConvergence_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "iterationsUntilConvergence"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val iterationsUntilConvergence$args = IterationsUntilConvergence.Args
  type iterationsUntilConvergence$args = IterationsUntilConvergence.Args

  val iterationsUntilConvergence$result = IterationsUntilConvergence.Result
  type iterationsUntilConvergence$result = IterationsUntilConvergence.Result

  object RankModels extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("rankModels_args")
      val ModelIdsField: TField = new TField("modelIds", TType.LIST, 1)
      val ModelIdsFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val MetricField: TField = new TField("metric", TType.ENUM, 2)
      val MetricFieldI32: TField = new TField("metric", TType.I32, 2)
      val MetricFieldManifest: Manifest[modeldb.ModelRankMetric] = implicitly[Manifest[modeldb.ModelRankMetric]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdsField,
          false,
          false,
          ModelIdsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          MetricField,
          false,
          false,
          MetricFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelIds)
        buf ++= validateField(item.metric)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelIds =
            {
              val field = original.modelIds
              field.map { field =>
                field
              }
            },
          metric =
            {
              val field = original.metric
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelIds: Seq[Int] = Seq[Int]()
        var metric: modeldb.ModelRankMetric = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    modelIds = readModelIdsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'modelIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 | TType.ENUM =>
                    metric = readMetricValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.ENUM
                    throw new TProtocolException(
                      "Received wrong type for field 'metric' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelIds,
          metric,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelIds: Seq[Int] = Seq[Int](),
        metric: modeldb.ModelRankMetric
      ): Args =
        new Args(
          modelIds,
          metric
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Seq[Int], modeldb.ModelRankMetric]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdsValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeModelIdsField(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdsField)
        writeModelIdsValue(modelIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdsValue(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, modelIds_item.size))
        modelIds_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = modelIds_item.size
            while (_i < _size) {
              val modelIds_item_element = modelIds_item(_i)
              _oprot.writeI32(modelIds_item_element)
              _i += 1
            }
          case _ =>
            modelIds_item.foreach { modelIds_item_element =>
              _oprot.writeI32(modelIds_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readMetricValue(_iprot: TProtocol): modeldb.ModelRankMetric = {
        modeldb.ModelRankMetric.getOrUnknown(_iprot.readI32())
      }
    
      @inline private def writeMetricField(metric_item: modeldb.ModelRankMetric, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(MetricFieldI32)
        writeMetricValue(metric_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeMetricValue(metric_item: modeldb.ModelRankMetric, _oprot: TProtocol): Unit = {
        _oprot.writeI32(metric_item.value)
      }
    
    
    }
    
    class Args(
        val modelIds: Seq[Int],
        val metric: modeldb.ModelRankMetric,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Seq[Int], modeldb.ModelRankMetric]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelIds: Seq[Int] = Seq[Int](),
        metric: modeldb.ModelRankMetric
      ) = this(
        modelIds,
        metric,
        Map.empty
      )
    
      def _1: Seq[Int] = modelIds
      def _2: modeldb.ModelRankMetric = metric
    
      def toTuple: _root_.scala.Tuple2[Seq[Int], modeldb.ModelRankMetric] = {
        (
          modelIds,
          metric
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (modelIds ne null) writeModelIdsField(modelIds, _oprot)
        if (metric ne null) writeMetricField(metric, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelIds: Seq[Int] = this.modelIds,
        metric: modeldb.ModelRankMetric = this.metric,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelIds,
          metric,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelIds
        case 1 => this.metric
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("rankModels_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "rankModels"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val rankModels$args = RankModels.Args
  type rankModels$args = RankModels.Args

  val rankModels$result = RankModels.Result
  type rankModels$result = RankModels.Result

  object ConfidenceIntervals extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("confidenceIntervals_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val SigLevelField: TField = new TField("sigLevel", TType.DOUBLE, 2)
      val SigLevelFieldManifest: Manifest[Double] = implicitly[Manifest[Double]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SigLevelField,
          false,
          false,
          SigLevelFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.sigLevel)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          sigLevel =
            {
              val field = original.sigLevel
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var sigLevel: Double = 0.0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.DOUBLE =>
                    sigLevel = readSigLevelValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.DOUBLE
                    throw new TProtocolException(
                      "Received wrong type for field 'sigLevel' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          sigLevel,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        sigLevel: Double
      ): Args =
        new Args(
          modelId,
          sigLevel
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Double]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readSigLevelValue(_iprot: TProtocol): Double = {
        _iprot.readDouble()
      }
    
      @inline private def writeSigLevelField(sigLevel_item: Double, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SigLevelField)
        writeSigLevelValue(sigLevel_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSigLevelValue(sigLevel_item: Double, _oprot: TProtocol): Unit = {
        _oprot.writeDouble(sigLevel_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val sigLevel: Double,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Double]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        sigLevel: Double
      ) = this(
        modelId,
        sigLevel,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: Double = sigLevel
    
      def toTuple: _root_.scala.Tuple2[Int, Double] = {
        (
          modelId,
          sigLevel
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        writeSigLevelField(sigLevel, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        sigLevel: Double = this.sigLevel,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          sigLevel,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.sigLevel
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[modeldb.ConfidenceInterval]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("confidenceIntervals_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[modeldb.ConfidenceInterval]] = implicitly[Manifest[Seq[modeldb.ConfidenceInterval]]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val IoExField: TField = new TField("ioEx", TType.STRUCT, 2)
      val IoExFieldManifest: Manifest[modeldb.IllegalOperationException] = implicitly[Manifest[modeldb.IllegalOperationException]]
      val BrExField: TField = new TField("brEx", TType.STRUCT, 3)
      val BrExFieldManifest: Manifest[modeldb.BadRequestException] = implicitly[Manifest[modeldb.BadRequestException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 4)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[modeldb.ConfidenceInterval]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IoExField,
          true,
          false,
          IoExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          BrExField,
          true,
          false,
          BrExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.ioEx)
        buf ++= validateField(item.brEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  modeldb.ConfidenceInterval.withoutPassthroughFields(field)
                }
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          ioEx =
            {
              val field = original.ioEx
              field.map { field =>
                modeldb.IllegalOperationException.withoutPassthroughFields(field)
              }
            },
          brEx =
            {
              val field = original.brEx
              field.map { field =>
                modeldb.BadRequestException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[modeldb.ConfidenceInterval]] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None
        var brEx: _root_.scala.Option[modeldb.BadRequestException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ioEx = _root_.scala.Some(readIoExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ioEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    brEx = _root_.scala.Some(readBrExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'brEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          ioEx,
          brEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[modeldb.ConfidenceInterval]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None,
        brEx: _root_.scala.Option[modeldb.BadRequestException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          ioEx,
          brEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple5[Option[Seq[modeldb.ConfidenceInterval]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.BadRequestException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[modeldb.ConfidenceInterval] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[modeldb.ConfidenceInterval](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              modeldb.ConfidenceInterval.decode(_iprot)
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[modeldb.ConfidenceInterval], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[modeldb.ConfidenceInterval], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRUCT, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              success_item_element.write(_oprot)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              success_item_element.write(_oprot)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readIoExValue(_iprot: TProtocol): modeldb.IllegalOperationException = {
        modeldb.IllegalOperationException.decode(_iprot)
      }
    
      @inline private def writeIoExField(ioEx_item: modeldb.IllegalOperationException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IoExField)
        writeIoExValue(ioEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIoExValue(ioEx_item: modeldb.IllegalOperationException, _oprot: TProtocol): Unit = {
        ioEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readBrExValue(_iprot: TProtocol): modeldb.BadRequestException = {
        modeldb.BadRequestException.decode(_iprot)
      }
    
      @inline private def writeBrExField(brEx_item: modeldb.BadRequestException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(BrExField)
        writeBrExValue(brEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeBrExValue(brEx_item: modeldb.BadRequestException, _oprot: TProtocol): Unit = {
        brEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[modeldb.ConfidenceInterval]],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val ioEx: _root_.scala.Option[modeldb.IllegalOperationException],
        val brEx: _root_.scala.Option[modeldb.BadRequestException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[modeldb.ConfidenceInterval]] with ThriftStruct
      with _root_.scala.Product5[Option[Seq[modeldb.ConfidenceInterval]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.BadRequestException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[modeldb.ConfidenceInterval]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None,
        brEx: _root_.scala.Option[modeldb.BadRequestException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        ioEx,
        brEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[modeldb.ConfidenceInterval]] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.IllegalOperationException] = ioEx
      def _4: _root_.scala.Option[modeldb.BadRequestException] = brEx
      def _5: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple5[Option[Seq[modeldb.ConfidenceInterval]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.BadRequestException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          ioEx,
          brEx,
          svEx
        )
      }
    
      def successField: Option[Seq[modeldb.ConfidenceInterval]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, ioEx, brEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (ioEx.isDefined) writeIoExField(ioEx.get, _oprot)
        if (brEx.isDefined) writeBrExField(brEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[modeldb.ConfidenceInterval]] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = this.ioEx,
        brEx: _root_.scala.Option[modeldb.BadRequestException] = this.brEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          ioEx,
          brEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 5
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.ioEx
        case 3 => this.brEx
        case 4 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "confidenceIntervals"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val confidenceIntervals$args = ConfidenceIntervals.Args
  type confidenceIntervals$args = ConfidenceIntervals.Args

  val confidenceIntervals$result = ConfidenceIntervals.Result
  type confidenceIntervals$result = ConfidenceIntervals.Result

  object ModelsWithFeatures extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("modelsWithFeatures_args")
      val FeatureNamesField: TField = new TField("featureNames", TType.LIST, 1)
      val FeatureNamesFieldManifest: Manifest[Seq[String]] = implicitly[Manifest[Seq[String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          FeatureNamesField,
          false,
          false,
          FeatureNamesFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.featureNames)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          featureNames =
            {
              val field = original.featureNames
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var featureNames: Seq[String] = Seq[String]()
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    featureNames = readFeatureNamesValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'featureNames' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          featureNames,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        featureNames: Seq[String] = Seq[String]()
      ): Args =
        new Args(
          featureNames
        )
    
      def unapply(_item: Args): _root_.scala.Option[Seq[String]] = _root_.scala.Some(_item.featureNames)
    
    
      @inline private[modeldb] def readFeatureNamesValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeFeatureNamesField(featureNames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(FeatureNamesField)
        writeFeatureNamesValue(featureNames_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeFeatureNamesValue(featureNames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, featureNames_item.size))
        featureNames_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = featureNames_item.size
            while (_i < _size) {
              val featureNames_item_element = featureNames_item(_i)
              _oprot.writeString(featureNames_item_element)
              _i += 1
            }
          case _ =>
            featureNames_item.foreach { featureNames_item_element =>
              _oprot.writeString(featureNames_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val featureNames: Seq[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Seq[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        featureNames: Seq[String] = Seq[String]()
      ) = this(
        featureNames,
        Map.empty
      )
    
      def _1: Seq[String] = featureNames
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (featureNames ne null) writeFeatureNamesField(featureNames, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        featureNames: Seq[String] = this.featureNames,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          featureNames,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.featureNames
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("modelsWithFeatures_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "modelsWithFeatures"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val modelsWithFeatures$args = ModelsWithFeatures.Args
  type modelsWithFeatures$args = ModelsWithFeatures.Args

  val modelsWithFeatures$result = ModelsWithFeatures.Result
  type modelsWithFeatures$result = ModelsWithFeatures.Result

  object ModelsDerivedFromDataFrame extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("modelsDerivedFromDataFrame_args")
      val DfIdField: TField = new TField("dfId", TType.I32, 1)
      val DfIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          DfIdField,
          false,
          false,
          DfIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.dfId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          dfId =
            {
              val field = original.dfId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var dfId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    dfId = readDfIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'dfId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          dfId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        dfId: Int
      ): Args =
        new Args(
          dfId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.dfId)
    
    
      @inline private[modeldb] def readDfIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeDfIdField(dfId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(DfIdField)
        writeDfIdValue(dfId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeDfIdValue(dfId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(dfId_item)
      }
    
    
    }
    
    class Args(
        val dfId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        dfId: Int
      ) = this(
        dfId,
        Map.empty
      )
    
      def _1: Int = dfId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeDfIdField(dfId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        dfId: Int = this.dfId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          dfId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.dfId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("modelsDerivedFromDataFrame_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[Seq[Int]], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product3[Option[Seq[Int]], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[Seq[Int]], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "modelsDerivedFromDataFrame"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val modelsDerivedFromDataFrame$args = ModelsDerivedFromDataFrame.Args
  type modelsDerivedFromDataFrame$args = ModelsDerivedFromDataFrame.Args

  val modelsDerivedFromDataFrame$result = ModelsDerivedFromDataFrame.Result
  type modelsDerivedFromDataFrame$result = ModelsDerivedFromDataFrame.Result

  object GetProjectIds extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getProjectIds_args")
      val KeyValuePairsField: TField = new TField("keyValuePairs", TType.MAP, 1)
      val KeyValuePairsFieldManifest: Manifest[Map[String, String]] = implicitly[Manifest[Map[String, String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          KeyValuePairsField,
          false,
          false,
          KeyValuePairsFieldManifest,
          _root_.scala.Some(implicitly[Manifest[String]]),
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.keyValuePairs)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          keyValuePairs =
            {
              val field = original.keyValuePairs
              field.map { case (key, value) =>
                  val newKey = {
                  val field = key
                  field
                }
  
          
                  val newValue = {
                  val field = value
                  field
                }
  
          
                newKey -> newValue
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var keyValuePairs: Map[String, String] = Map[String, String]()
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.MAP =>
                    keyValuePairs = readKeyValuePairsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.MAP
                    throw new TProtocolException(
                      "Received wrong type for field 'keyValuePairs' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          keyValuePairs,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        keyValuePairs: Map[String, String] = Map[String, String]()
      ): Args =
        new Args(
          keyValuePairs
        )
    
      def unapply(_item: Args): _root_.scala.Option[Map[String, String]] = _root_.scala.Some(_item.keyValuePairs)
    
    
      @inline private[modeldb] def readKeyValuePairsValue(_iprot: TProtocol): Map[String, String] = {
        val _map = _iprot.readMapBegin()
        if (_map.size == 0) {
          _iprot.readMapEnd()
          Map.empty[String, String]
        } else {
          val _rv = new mutable$HashMap[String, String]
          var _i = 0
          while (_i < _map.size) {
            val _key = {
              _iprot.readString()
            }
            val _value = {
              _iprot.readString()
            }
            _rv(_key) = _value
            _i += 1
          }
          _iprot.readMapEnd()
          _rv
        }
      }
    
      @inline private def writeKeyValuePairsField(keyValuePairs_item: Map[String, String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(KeyValuePairsField)
        writeKeyValuePairsValue(keyValuePairs_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeKeyValuePairsValue(keyValuePairs_item: Map[String, String], _oprot: TProtocol): Unit = {
        _oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, keyValuePairs_item.size))
        keyValuePairs_item.foreach { case (keyValuePairs_item_key, keyValuePairs_item_value) =>
          _oprot.writeString(keyValuePairs_item_key)
          _oprot.writeString(keyValuePairs_item_value)
        }
        _oprot.writeMapEnd()
      }
    
    
    }
    
    class Args(
        val keyValuePairs: Map[String, String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Map[String, String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        keyValuePairs: Map[String, String] = Map[String, String]()
      ) = this(
        keyValuePairs,
        Map.empty
      )
    
      def _1: Map[String, String] = keyValuePairs
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (keyValuePairs ne null) writeKeyValuePairsField(keyValuePairs, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        keyValuePairs: Map[String, String] = this.keyValuePairs,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          keyValuePairs,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.keyValuePairs
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getProjectIds_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "getProjectIds"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getProjectIds$args = GetProjectIds.Args
  type getProjectIds$args = GetProjectIds.Args

  val getProjectIds$result = GetProjectIds.Result
  type getProjectIds$result = GetProjectIds.Result

  object GetModelIds extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getModelIds_args")
      val KeyValuePairsField: TField = new TField("keyValuePairs", TType.MAP, 1)
      val KeyValuePairsFieldManifest: Manifest[Map[String, String]] = implicitly[Manifest[Map[String, String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          KeyValuePairsField,
          false,
          false,
          KeyValuePairsFieldManifest,
          _root_.scala.Some(implicitly[Manifest[String]]),
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.keyValuePairs)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          keyValuePairs =
            {
              val field = original.keyValuePairs
              field.map { case (key, value) =>
                  val newKey = {
                  val field = key
                  field
                }
  
          
                  val newValue = {
                  val field = value
                  field
                }
  
          
                newKey -> newValue
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var keyValuePairs: Map[String, String] = Map[String, String]()
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.MAP =>
                    keyValuePairs = readKeyValuePairsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.MAP
                    throw new TProtocolException(
                      "Received wrong type for field 'keyValuePairs' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          keyValuePairs,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        keyValuePairs: Map[String, String] = Map[String, String]()
      ): Args =
        new Args(
          keyValuePairs
        )
    
      def unapply(_item: Args): _root_.scala.Option[Map[String, String]] = _root_.scala.Some(_item.keyValuePairs)
    
    
      @inline private[modeldb] def readKeyValuePairsValue(_iprot: TProtocol): Map[String, String] = {
        val _map = _iprot.readMapBegin()
        if (_map.size == 0) {
          _iprot.readMapEnd()
          Map.empty[String, String]
        } else {
          val _rv = new mutable$HashMap[String, String]
          var _i = 0
          while (_i < _map.size) {
            val _key = {
              _iprot.readString()
            }
            val _value = {
              _iprot.readString()
            }
            _rv(_key) = _value
            _i += 1
          }
          _iprot.readMapEnd()
          _rv
        }
      }
    
      @inline private def writeKeyValuePairsField(keyValuePairs_item: Map[String, String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(KeyValuePairsField)
        writeKeyValuePairsValue(keyValuePairs_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeKeyValuePairsValue(keyValuePairs_item: Map[String, String], _oprot: TProtocol): Unit = {
        _oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, keyValuePairs_item.size))
        keyValuePairs_item.foreach { case (keyValuePairs_item_key, keyValuePairs_item_value) =>
          _oprot.writeString(keyValuePairs_item_key)
          _oprot.writeString(keyValuePairs_item_value)
        }
        _oprot.writeMapEnd()
      }
    
    
    }
    
    class Args(
        val keyValuePairs: Map[String, String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Map[String, String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        keyValuePairs: Map[String, String] = Map[String, String]()
      ) = this(
        keyValuePairs,
        Map.empty
      )
    
      def _1: Map[String, String] = keyValuePairs
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (keyValuePairs ne null) writeKeyValuePairsField(keyValuePairs, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        keyValuePairs: Map[String, String] = this.keyValuePairs,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          keyValuePairs,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.keyValuePairs
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getModelIds_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "getModelIds"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getModelIds$args = GetModelIds.Args
  type getModelIds$args = GetModelIds.Args

  val getModelIds$result = GetModelIds.Result
  type getModelIds$result = GetModelIds.Result

  object UpdateProject extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("updateProject_args")
      val ProjectIdField: TField = new TField("projectId", TType.I32, 1)
      val ProjectIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val KeyField: TField = new TField("key", TType.STRING, 2)
      val KeyFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val ValueField: TField = new TField("value", TType.STRING, 3)
      val ValueFieldManifest: Manifest[String] = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ProjectIdField,
          false,
          false,
          ProjectIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          KeyField,
          false,
          false,
          KeyFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueField,
          false,
          false,
          ValueFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.projectId)
        buf ++= validateField(item.key)
        buf ++= validateField(item.value)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          projectId =
            {
              val field = original.projectId
              field
            },
          key =
            {
              val field = original.key
              field
            },
          value =
            {
              val field = original.value
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var projectId: Int = 0
        var key: String = null
        var value: String = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    projectId = readProjectIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'projectId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    key = readKeyValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'key' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRING =>
                    value = readValueValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'value' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          projectId,
          key,
          value,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        projectId: Int,
        key: String,
        value: String
      ): Args =
        new Args(
          projectId,
          key,
          value
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[Int, String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readProjectIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeProjectIdField(projectId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ProjectIdField)
        writeProjectIdValue(projectId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeProjectIdValue(projectId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(projectId_item)
      }
    
      @inline private[modeldb] def readKeyValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeKeyField(key_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(KeyField)
        writeKeyValue(key_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeKeyValue(key_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(key_item)
      }
    
      @inline private[modeldb] def readValueValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeValueField(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueField)
        writeValueValue(value_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueValue(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(value_item)
      }
    
    
    }
    
    class Args(
        val projectId: Int,
        val key: String,
        val value: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[Int, String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        projectId: Int,
        key: String,
        value: String
      ) = this(
        projectId,
        key,
        value,
        Map.empty
      )
    
      def _1: Int = projectId
      def _2: String = key
      def _3: String = value
    
      def toTuple: _root_.scala.Tuple3[Int, String, String] = {
        (
          projectId,
          key,
          value
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeProjectIdField(projectId, _oprot)
        if (key ne null) writeKeyField(key, _oprot)
        if (value ne null) writeValueField(value, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        projectId: Int = this.projectId,
        key: String = this.key,
        value: String = this.value,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          projectId,
          key,
          value,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.projectId
        case 1 => this.key
        case 2 => this.value
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("updateProject_result")
      val SuccessField: TField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest: Manifest[Boolean] = implicitly[Manifest[Boolean]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product2[Option[Boolean], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Boolean] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "updateProject"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val updateProject$args = UpdateProject.Args
  type updateProject$args = UpdateProject.Args

  val updateProject$result = UpdateProject.Result
  type updateProject$result = UpdateProject.Result

  object CreateOrUpdateScalarField extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("createOrUpdateScalarField_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val KeyField: TField = new TField("key", TType.STRING, 2)
      val KeyFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val ValueField: TField = new TField("value", TType.STRING, 3)
      val ValueFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val ValueTypeField: TField = new TField("valueType", TType.STRING, 4)
      val ValueTypeFieldManifest: Manifest[String] = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          KeyField,
          false,
          false,
          KeyFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueField,
          false,
          false,
          ValueFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueTypeField,
          false,
          false,
          ValueTypeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.key)
        buf ++= validateField(item.value)
        buf ++= validateField(item.valueType)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          key =
            {
              val field = original.key
              field
            },
          value =
            {
              val field = original.value
              field
            },
          valueType =
            {
              val field = original.valueType
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var key: String = null
        var value: String = null
        var valueType: String = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    key = readKeyValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'key' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRING =>
                    value = readValueValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'value' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.STRING =>
                    valueType = readValueTypeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'valueType' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          key,
          value,
          valueType,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        key: String,
        value: String,
        valueType: String
      ): Args =
        new Args(
          modelId,
          key,
          value,
          valueType
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple4[Int, String, String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readKeyValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeKeyField(key_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(KeyField)
        writeKeyValue(key_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeKeyValue(key_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(key_item)
      }
    
      @inline private[modeldb] def readValueValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeValueField(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueField)
        writeValueValue(value_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueValue(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(value_item)
      }
    
      @inline private[modeldb] def readValueTypeValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeValueTypeField(valueType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueTypeField)
        writeValueTypeValue(valueType_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueTypeValue(valueType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(valueType_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val key: String,
        val value: String,
        val valueType: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product4[Int, String, String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        key: String,
        value: String,
        valueType: String
      ) = this(
        modelId,
        key,
        value,
        valueType,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: String = key
      def _3: String = value
      def _4: String = valueType
    
      def toTuple: _root_.scala.Tuple4[Int, String, String, String] = {
        (
          modelId,
          key,
          value,
          valueType
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (key ne null) writeKeyField(key, _oprot)
        if (value ne null) writeValueField(value, _oprot)
        if (valueType ne null) writeValueTypeField(valueType, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        key: String = this.key,
        value: String = this.value,
        valueType: String = this.valueType,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          key,
          value,
          valueType,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.key
        case 2 => this.value
        case 3 => this.valueType
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("createOrUpdateScalarField_result")
      val SuccessField: TField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest: Manifest[Boolean] = implicitly[Manifest[Boolean]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product2[Option[Boolean], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Boolean] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "createOrUpdateScalarField"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val createOrUpdateScalarField$args = CreateOrUpdateScalarField.Args
  type createOrUpdateScalarField$args = CreateOrUpdateScalarField.Args

  val createOrUpdateScalarField$result = CreateOrUpdateScalarField.Result
  type createOrUpdateScalarField$result = CreateOrUpdateScalarField.Result

  object CreateVectorField extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("createVectorField_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val VectorNameField: TField = new TField("vectorName", TType.STRING, 2)
      val VectorNameFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val VectorConfigField: TField = new TField("vectorConfig", TType.MAP, 3)
      val VectorConfigFieldManifest: Manifest[Map[String, String]] = implicitly[Manifest[Map[String, String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          VectorNameField,
          false,
          false,
          VectorNameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          VectorConfigField,
          false,
          false,
          VectorConfigFieldManifest,
          _root_.scala.Some(implicitly[Manifest[String]]),
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.vectorName)
        buf ++= validateField(item.vectorConfig)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          vectorName =
            {
              val field = original.vectorName
              field
            },
          vectorConfig =
            {
              val field = original.vectorConfig
              field.map { case (key, value) =>
                  val newKey = {
                  val field = key
                  field
                }
  
          
                  val newValue = {
                  val field = value
                  field
                }
  
          
                newKey -> newValue
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var vectorName: String = null
        var vectorConfig: Map[String, String] = Map[String, String]()
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    vectorName = readVectorNameValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'vectorName' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.MAP =>
                    vectorConfig = readVectorConfigValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.MAP
                    throw new TProtocolException(
                      "Received wrong type for field 'vectorConfig' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          vectorName,
          vectorConfig,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        vectorName: String,
        vectorConfig: Map[String, String] = Map[String, String]()
      ): Args =
        new Args(
          modelId,
          vectorName,
          vectorConfig
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[Int, String, Map[String, String]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readVectorNameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeVectorNameField(vectorName_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(VectorNameField)
        writeVectorNameValue(vectorName_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeVectorNameValue(vectorName_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(vectorName_item)
      }
    
      @inline private[modeldb] def readVectorConfigValue(_iprot: TProtocol): Map[String, String] = {
        val _map = _iprot.readMapBegin()
        if (_map.size == 0) {
          _iprot.readMapEnd()
          Map.empty[String, String]
        } else {
          val _rv = new mutable$HashMap[String, String]
          var _i = 0
          while (_i < _map.size) {
            val _key = {
              _iprot.readString()
            }
            val _value = {
              _iprot.readString()
            }
            _rv(_key) = _value
            _i += 1
          }
          _iprot.readMapEnd()
          _rv
        }
      }
    
      @inline private def writeVectorConfigField(vectorConfig_item: Map[String, String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(VectorConfigField)
        writeVectorConfigValue(vectorConfig_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeVectorConfigValue(vectorConfig_item: Map[String, String], _oprot: TProtocol): Unit = {
        _oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, vectorConfig_item.size))
        vectorConfig_item.foreach { case (vectorConfig_item_key, vectorConfig_item_value) =>
          _oprot.writeString(vectorConfig_item_key)
          _oprot.writeString(vectorConfig_item_value)
        }
        _oprot.writeMapEnd()
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val vectorName: String,
        val vectorConfig: Map[String, String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[Int, String, Map[String, String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        vectorName: String,
        vectorConfig: Map[String, String] = Map[String, String]()
      ) = this(
        modelId,
        vectorName,
        vectorConfig,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: String = vectorName
      def _3: Map[String, String] = vectorConfig
    
      def toTuple: _root_.scala.Tuple3[Int, String, Map[String, String]] = {
        (
          modelId,
          vectorName,
          vectorConfig
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (vectorName ne null) writeVectorNameField(vectorName, _oprot)
        if (vectorConfig ne null) writeVectorConfigField(vectorConfig, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        vectorName: String = this.vectorName,
        vectorConfig: Map[String, String] = this.vectorConfig,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          vectorName,
          vectorConfig,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.vectorName
        case 2 => this.vectorConfig
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("createVectorField_result")
      val SuccessField: TField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest: Manifest[Boolean] = implicitly[Manifest[Boolean]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product2[Option[Boolean], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Boolean] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "createVectorField"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val createVectorField$args = CreateVectorField.Args
  type createVectorField$args = CreateVectorField.Args

  val createVectorField$result = CreateVectorField.Result
  type createVectorField$result = CreateVectorField.Result

  object UpdateVectorField extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("updateVectorField_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val KeyField: TField = new TField("key", TType.STRING, 2)
      val KeyFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val ValueIndexField: TField = new TField("valueIndex", TType.I32, 3)
      val ValueIndexFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val ValueField: TField = new TField("value", TType.STRING, 4)
      val ValueFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val ValueTypeField: TField = new TField("valueType", TType.STRING, 5)
      val ValueTypeFieldManifest: Manifest[String] = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          KeyField,
          false,
          false,
          KeyFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueIndexField,
          false,
          false,
          ValueIndexFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueField,
          false,
          false,
          ValueFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueTypeField,
          false,
          false,
          ValueTypeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.key)
        buf ++= validateField(item.valueIndex)
        buf ++= validateField(item.value)
        buf ++= validateField(item.valueType)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          key =
            {
              val field = original.key
              field
            },
          valueIndex =
            {
              val field = original.valueIndex
              field
            },
          value =
            {
              val field = original.value
              field
            },
          valueType =
            {
              val field = original.valueType
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var key: String = null
        var valueIndex: Int = 0
        var value: String = null
        var valueType: String = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    key = readKeyValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'key' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.I32 =>
                    valueIndex = readValueIndexValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'valueIndex' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.STRING =>
                    value = readValueValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'value' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 5 =>
                _field.`type` match {
                  case TType.STRING =>
                    valueType = readValueTypeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'valueType' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          key,
          valueIndex,
          value,
          valueType,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        key: String,
        valueIndex: Int,
        value: String,
        valueType: String
      ): Args =
        new Args(
          modelId,
          key,
          valueIndex,
          value,
          valueType
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple5[Int, String, Int, String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readKeyValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeKeyField(key_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(KeyField)
        writeKeyValue(key_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeKeyValue(key_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(key_item)
      }
    
      @inline private[modeldb] def readValueIndexValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeValueIndexField(valueIndex_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueIndexField)
        writeValueIndexValue(valueIndex_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueIndexValue(valueIndex_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(valueIndex_item)
      }
    
      @inline private[modeldb] def readValueValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeValueField(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueField)
        writeValueValue(value_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueValue(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(value_item)
      }
    
      @inline private[modeldb] def readValueTypeValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeValueTypeField(valueType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueTypeField)
        writeValueTypeValue(valueType_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueTypeValue(valueType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(valueType_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val key: String,
        val valueIndex: Int,
        val value: String,
        val valueType: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product5[Int, String, Int, String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        key: String,
        valueIndex: Int,
        value: String,
        valueType: String
      ) = this(
        modelId,
        key,
        valueIndex,
        value,
        valueType,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: String = key
      def _3: Int = valueIndex
      def _4: String = value
      def _5: String = valueType
    
      def toTuple: _root_.scala.Tuple5[Int, String, Int, String, String] = {
        (
          modelId,
          key,
          valueIndex,
          value,
          valueType
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (key ne null) writeKeyField(key, _oprot)
        writeValueIndexField(valueIndex, _oprot)
        if (value ne null) writeValueField(value, _oprot)
        if (valueType ne null) writeValueTypeField(valueType, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        key: String = this.key,
        valueIndex: Int = this.valueIndex,
        value: String = this.value,
        valueType: String = this.valueType,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          key,
          valueIndex,
          value,
          valueType,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 5
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.key
        case 2 => this.valueIndex
        case 3 => this.value
        case 4 => this.valueType
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("updateVectorField_result")
      val SuccessField: TField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest: Manifest[Boolean] = implicitly[Manifest[Boolean]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product2[Option[Boolean], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Boolean] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "updateVectorField"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val updateVectorField$args = UpdateVectorField.Args
  type updateVectorField$args = UpdateVectorField.Args

  val updateVectorField$result = UpdateVectorField.Result
  type updateVectorField$result = UpdateVectorField.Result

  object AppendToVectorField extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("appendToVectorField_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val VectorNameField: TField = new TField("vectorName", TType.STRING, 2)
      val VectorNameFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val ValueField: TField = new TField("value", TType.STRING, 3)
      val ValueFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val ValueTypeField: TField = new TField("valueType", TType.STRING, 4)
      val ValueTypeFieldManifest: Manifest[String] = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          VectorNameField,
          false,
          false,
          VectorNameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueField,
          false,
          false,
          ValueFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueTypeField,
          false,
          false,
          ValueTypeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.vectorName)
        buf ++= validateField(item.value)
        buf ++= validateField(item.valueType)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          vectorName =
            {
              val field = original.vectorName
              field
            },
          value =
            {
              val field = original.value
              field
            },
          valueType =
            {
              val field = original.valueType
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var vectorName: String = null
        var value: String = null
        var valueType: String = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    vectorName = readVectorNameValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'vectorName' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRING =>
                    value = readValueValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'value' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.STRING =>
                    valueType = readValueTypeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'valueType' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          vectorName,
          value,
          valueType,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        vectorName: String,
        value: String,
        valueType: String
      ): Args =
        new Args(
          modelId,
          vectorName,
          value,
          valueType
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple4[Int, String, String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readVectorNameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeVectorNameField(vectorName_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(VectorNameField)
        writeVectorNameValue(vectorName_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeVectorNameValue(vectorName_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(vectorName_item)
      }
    
      @inline private[modeldb] def readValueValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeValueField(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueField)
        writeValueValue(value_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueValue(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(value_item)
      }
    
      @inline private[modeldb] def readValueTypeValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeValueTypeField(valueType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueTypeField)
        writeValueTypeValue(valueType_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueTypeValue(valueType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(valueType_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val vectorName: String,
        val value: String,
        val valueType: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product4[Int, String, String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        vectorName: String,
        value: String,
        valueType: String
      ) = this(
        modelId,
        vectorName,
        value,
        valueType,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: String = vectorName
      def _3: String = value
      def _4: String = valueType
    
      def toTuple: _root_.scala.Tuple4[Int, String, String, String] = {
        (
          modelId,
          vectorName,
          value,
          valueType
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (vectorName ne null) writeVectorNameField(vectorName, _oprot)
        if (value ne null) writeValueField(value, _oprot)
        if (valueType ne null) writeValueTypeField(valueType, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        vectorName: String = this.vectorName,
        value: String = this.value,
        valueType: String = this.valueType,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          vectorName,
          value,
          valueType,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.vectorName
        case 2 => this.value
        case 3 => this.valueType
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("appendToVectorField_result")
      val SuccessField: TField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest: Manifest[Boolean] = implicitly[Manifest[Boolean]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product2[Option[Boolean], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Boolean] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "appendToVectorField"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val appendToVectorField$args = AppendToVectorField.Args
  type appendToVectorField$args = AppendToVectorField.Args

  val appendToVectorField$result = AppendToVectorField.Result
  type appendToVectorField$result = AppendToVectorField.Result

  object GetModel extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getModel_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int
      ): Args =
        new Args(
          modelId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.modelId)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int
      ) = this(
        modelId,
        Map.empty
      )
    
      def _1: Int = modelId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ModelResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getModel_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ModelResponse] = implicitly[Manifest[modeldb.ModelResponse]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ModelResponse.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ModelResponse] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ModelResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.ModelResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ModelResponse = {
        modeldb.ModelResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ModelResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ModelResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ModelResponse],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ModelResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.ModelResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ModelResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ModelResponse] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.ModelResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.ModelResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ModelResponse] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "getModel"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getModel$args = GetModel.Args
  type getModel$args = GetModel.Args

  val getModel$result = GetModel.Result
  type getModel$result = GetModel.Result

  object GetRunsInExperiment extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getRunsInExperiment_args")
      val ExperimentIdField: TField = new TField("experimentId", TType.I32, 1)
      val ExperimentIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ExperimentIdField,
          false,
          false,
          ExperimentIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.experimentId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          experimentId =
            {
              val field = original.experimentId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var experimentId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    experimentId = readExperimentIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'experimentId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          experimentId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        experimentId: Int
      ): Args =
        new Args(
          experimentId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.experimentId)
    
    
      @inline private[modeldb] def readExperimentIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeExperimentIdField(experimentId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ExperimentIdField)
        writeExperimentIdValue(experimentId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeExperimentIdValue(experimentId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(experimentId_item)
      }
    
    
    }
    
    class Args(
        val experimentId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        experimentId: Int
      ) = this(
        experimentId,
        Map.empty
      )
    
      def _1: Int = experimentId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeExperimentIdField(experimentId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        experimentId: Int = this.experimentId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          experimentId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.experimentId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[modeldb.ExperimentRun]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getRunsInExperiment_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[modeldb.ExperimentRun]] = implicitly[Manifest[Seq[modeldb.ExperimentRun]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[modeldb.ExperimentRun]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  modeldb.ExperimentRun.withoutPassthroughFields(field)
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[modeldb.ExperimentRun]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[modeldb.ExperimentRun]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[modeldb.ExperimentRun]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[modeldb.ExperimentRun] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[modeldb.ExperimentRun](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              modeldb.ExperimentRun.decode(_iprot)
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[modeldb.ExperimentRun], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[modeldb.ExperimentRun], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRUCT, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              success_item_element.write(_oprot)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              success_item_element.write(_oprot)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[modeldb.ExperimentRun]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[modeldb.ExperimentRun]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[modeldb.ExperimentRun]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[modeldb.ExperimentRun]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[modeldb.ExperimentRun]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[modeldb.ExperimentRun]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[modeldb.ExperimentRun]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[modeldb.ExperimentRun]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "getRunsInExperiment"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getRunsInExperiment$args = GetRunsInExperiment.Args
  type getRunsInExperiment$args = GetRunsInExperiment.Args

  val getRunsInExperiment$result = GetRunsInExperiment.Result
  type getRunsInExperiment$result = GetRunsInExperiment.Result

  object GetRunsAndExperimentsInProject extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getRunsAndExperimentsInProject_args")
      val ProjIdField: TField = new TField("projId", TType.I32, 1)
      val ProjIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ProjIdField,
          false,
          false,
          ProjIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.projId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          projId =
            {
              val field = original.projId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var projId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    projId = readProjIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'projId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          projId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        projId: Int
      ): Args =
        new Args(
          projId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.projId)
    
    
      @inline private[modeldb] def readProjIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeProjIdField(projId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ProjIdField)
        writeProjIdValue(projId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeProjIdValue(projId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(projId_item)
      }
    
    
    }
    
    class Args(
        val projId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        projId: Int
      ) = this(
        projId,
        Map.empty
      )
    
      def _1: Int = projId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeProjIdField(projId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        projId: Int = this.projId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          projId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.projId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ProjectExperimentsAndRuns
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getRunsAndExperimentsInProject_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ProjectExperimentsAndRuns] = implicitly[Manifest[modeldb.ProjectExperimentsAndRuns]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ProjectExperimentsAndRuns.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ProjectExperimentsAndRuns] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ProjectExperimentsAndRuns] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.ProjectExperimentsAndRuns], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ProjectExperimentsAndRuns = {
        modeldb.ProjectExperimentsAndRuns.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ProjectExperimentsAndRuns, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ProjectExperimentsAndRuns, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ProjectExperimentsAndRuns],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ProjectExperimentsAndRuns] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.ProjectExperimentsAndRuns], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ProjectExperimentsAndRuns] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ProjectExperimentsAndRuns] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.ProjectExperimentsAndRuns], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.ProjectExperimentsAndRuns] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ProjectExperimentsAndRuns] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "getRunsAndExperimentsInProject"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getRunsAndExperimentsInProject$args = GetRunsAndExperimentsInProject.Args
  type getRunsAndExperimentsInProject$args = GetRunsAndExperimentsInProject.Args

  val getRunsAndExperimentsInProject$result = GetRunsAndExperimentsInProject.Result
  type getRunsAndExperimentsInProject$result = GetRunsAndExperimentsInProject.Result

  object GetProjectOverviews extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getProjectOverviews_args")
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
      ): Args =
        new Args(
        )
    
      def unapply(_item: Args): Boolean = true
    
    
    
    }
    
    class Args(
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
      ) = this(
        Map.empty
      )
    
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[modeldb.ProjectOverviewResponse]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getProjectOverviews_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[modeldb.ProjectOverviewResponse]] = implicitly[Manifest[Seq[modeldb.ProjectOverviewResponse]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[modeldb.ProjectOverviewResponse]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  modeldb.ProjectOverviewResponse.withoutPassthroughFields(field)
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[modeldb.ProjectOverviewResponse]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[modeldb.ProjectOverviewResponse]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[modeldb.ProjectOverviewResponse]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[modeldb.ProjectOverviewResponse] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[modeldb.ProjectOverviewResponse](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              modeldb.ProjectOverviewResponse.decode(_iprot)
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[modeldb.ProjectOverviewResponse], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[modeldb.ProjectOverviewResponse], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRUCT, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              success_item_element.write(_oprot)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              success_item_element.write(_oprot)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[modeldb.ProjectOverviewResponse]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[modeldb.ProjectOverviewResponse]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[modeldb.ProjectOverviewResponse]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[modeldb.ProjectOverviewResponse]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[modeldb.ProjectOverviewResponse]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[modeldb.ProjectOverviewResponse]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[modeldb.ProjectOverviewResponse]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[modeldb.ProjectOverviewResponse]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "getProjectOverviews"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getProjectOverviews$args = GetProjectOverviews.Args
  type getProjectOverviews$args = GetProjectOverviews.Args

  val getProjectOverviews$result = GetProjectOverviews.Result
  type getProjectOverviews$result = GetProjectOverviews.Result

  object GetExperimentRunDetails extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getExperimentRunDetails_args")
      val ExperimentRunIdField: TField = new TField("experimentRunId", TType.I32, 1)
      val ExperimentRunIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ExperimentRunIdField,
          false,
          false,
          ExperimentRunIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.experimentRunId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          experimentRunId =
            {
              val field = original.experimentRunId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var experimentRunId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    experimentRunId = readExperimentRunIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'experimentRunId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          experimentRunId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        experimentRunId: Int
      ): Args =
        new Args(
          experimentRunId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.experimentRunId)
    
    
      @inline private[modeldb] def readExperimentRunIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeExperimentRunIdField(experimentRunId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ExperimentRunIdField)
        writeExperimentRunIdValue(experimentRunId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeExperimentRunIdValue(experimentRunId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(experimentRunId_item)
      }
    
    
    }
    
    class Args(
        val experimentRunId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        experimentRunId: Int
      ) = this(
        experimentRunId,
        Map.empty
      )
    
      def _1: Int = experimentRunId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeExperimentRunIdField(experimentRunId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        experimentRunId: Int = this.experimentRunId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          experimentRunId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.experimentRunId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ExperimentRunDetailsResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getExperimentRunDetails_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ExperimentRunDetailsResponse] = implicitly[Manifest[modeldb.ExperimentRunDetailsResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 2)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf ++= validateField(item.rnfEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ExperimentRunDetailsResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ExperimentRunDetailsResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          rnfEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ExperimentRunDetailsResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx,
          rnfEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.ExperimentRunDetailsResponse], Option[modeldb.ServerLogicException], Option[modeldb.ResourceNotFoundException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ExperimentRunDetailsResponse = {
        modeldb.ExperimentRunDetailsResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ExperimentRunDetailsResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ExperimentRunDetailsResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ExperimentRunDetailsResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ExperimentRunDetailsResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.ExperimentRunDetailsResponse], Option[modeldb.ServerLogicException], Option[modeldb.ResourceNotFoundException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ExperimentRunDetailsResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        rnfEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ExperimentRunDetailsResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
      def _3: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.ExperimentRunDetailsResponse], Option[modeldb.ServerLogicException], Option[modeldb.ResourceNotFoundException]] = {
        (
          success,
          svEx,
          rnfEx
        )
      }
    
      def successField: Option[modeldb.ExperimentRunDetailsResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx, rnfEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ExperimentRunDetailsResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          rnfEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case 2 => this.rnfEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "getExperimentRunDetails"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getExperimentRunDetails$args = GetExperimentRunDetails.Args
  type getExperimentRunDetails$args = GetExperimentRunDetails.Args

  val getExperimentRunDetails$result = GetExperimentRunDetails.Result
  type getExperimentRunDetails$result = GetExperimentRunDetails.Result

  object OriginalFeatures extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("originalFeatures_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int
      ): Args =
        new Args(
          modelId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.modelId)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int
      ) = this(
        modelId,
        Map.empty
      )
    
      def _1: Int = modelId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[String]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("originalFeatures_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[String]] = implicitly[Manifest[Seq[String]]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[String]] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[String]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[Seq[String]], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeString(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeString(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[String]],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[String]] with ThriftStruct
      with _root_.scala.Product3[Option[Seq[String]], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[String]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[String]] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[Seq[String]], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[Seq[String]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[String]] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "originalFeatures"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val originalFeatures$args = OriginalFeatures.Args
  type originalFeatures$args = OriginalFeatures.Args

  val originalFeatures$result = OriginalFeatures.Result
  type originalFeatures$result = OriginalFeatures.Result

  object StoreTreeModel extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeTreeModel_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val ModelField: TField = new TField("model", TType.STRUCT, 2)
      val ModelFieldManifest: Manifest[modeldb.TreeModel] = implicitly[Manifest[modeldb.TreeModel]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ModelField,
          false,
          false,
          ModelFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.model)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          model =
            {
              val field = original.model
              modeldb.TreeModel.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var model: modeldb.TreeModel = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    model = readModelValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'model' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          model,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        model: modeldb.TreeModel
      ): Args =
        new Args(
          modelId,
          model
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, modeldb.TreeModel]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readModelValue(_iprot: TProtocol): modeldb.TreeModel = {
        modeldb.TreeModel.decode(_iprot)
      }
    
      @inline private def writeModelField(model_item: modeldb.TreeModel, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelField)
        writeModelValue(model_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelValue(model_item: modeldb.TreeModel, _oprot: TProtocol): Unit = {
        model_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val model: modeldb.TreeModel,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, modeldb.TreeModel]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        model: modeldb.TreeModel
      ) = this(
        modelId,
        model,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: modeldb.TreeModel = model
    
      def toTuple: _root_.scala.Tuple2[Int, modeldb.TreeModel] = {
        (
          modelId,
          model
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (model ne null) writeModelField(model, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        model: modeldb.TreeModel = this.model,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          model,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.model
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeTreeModel_result")
      val SuccessField: TField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest: Manifest[Boolean] = implicitly[Manifest[Boolean]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[Boolean], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product3[Option[Boolean], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Boolean] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[Boolean], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storeTreeModel"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeTreeModel$args = StoreTreeModel.Args
  type storeTreeModel$args = StoreTreeModel.Args

  val storeTreeModel$result = StoreTreeModel.Result
  type storeTreeModel$result = StoreTreeModel.Result

  object StorePipelineTransformEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storePipelineTransformEvent_args")
      val TeField: TField = new TField("te", TType.LIST, 1)
      val TeFieldManifest: Manifest[Seq[modeldb.TransformEvent]] = implicitly[Manifest[Seq[modeldb.TransformEvent]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          TeField,
          false,
          false,
          TeFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[modeldb.TransformEvent]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.te)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          te =
            {
              val field = original.te
              field.map { field =>
                modeldb.TransformEvent.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var te: Seq[modeldb.TransformEvent] = Seq[modeldb.TransformEvent]()
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    te = readTeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'te' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          te,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        te: Seq[modeldb.TransformEvent] = Seq[modeldb.TransformEvent]()
      ): Args =
        new Args(
          te
        )
    
      def unapply(_item: Args): _root_.scala.Option[Seq[modeldb.TransformEvent]] = _root_.scala.Some(_item.te)
    
    
      @inline private[modeldb] def readTeValue(_iprot: TProtocol): Seq[modeldb.TransformEvent] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[modeldb.TransformEvent](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              modeldb.TransformEvent.decode(_iprot)
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeTeField(te_item: Seq[modeldb.TransformEvent], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(TeField)
        writeTeValue(te_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeTeValue(te_item: Seq[modeldb.TransformEvent], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRUCT, te_item.size))
        te_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = te_item.size
            while (_i < _size) {
              val te_item_element = te_item(_i)
              te_item_element.write(_oprot)
              _i += 1
            }
          case _ =>
            te_item.foreach { te_item_element =>
              te_item_element.write(_oprot)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val te: Seq[modeldb.TransformEvent],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Seq[modeldb.TransformEvent]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        te: Seq[modeldb.TransformEvent] = Seq[modeldb.TransformEvent]()
      ) = this(
        te,
        Map.empty
      )
    
      def _1: Seq[modeldb.TransformEvent] = te
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (te ne null) writeTeField(te, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        te: Seq[modeldb.TransformEvent] = this.te,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          te,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.te
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[modeldb.TransformEventResponse]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storePipelineTransformEvent_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[modeldb.TransformEventResponse]] = implicitly[Manifest[Seq[modeldb.TransformEventResponse]]]
      val IerExField: TField = new TField("ierEx", TType.STRUCT, 1)
      val IerExFieldManifest: Manifest[modeldb.InvalidExperimentRunException] = implicitly[Manifest[modeldb.InvalidExperimentRunException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[modeldb.TransformEventResponse]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IerExField,
          true,
          false,
          IerExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.ierEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  modeldb.TransformEventResponse.withoutPassthroughFields(field)
                }
              }
            },
          ierEx =
            {
              val field = original.ierEx
              field.map { field =>
                modeldb.InvalidExperimentRunException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[modeldb.TransformEventResponse]] = _root_.scala.None
        var ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ierEx = _root_.scala.Some(readIerExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ierEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          ierEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[modeldb.TransformEventResponse]] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          ierEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[Seq[modeldb.TransformEventResponse]], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[modeldb.TransformEventResponse] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[modeldb.TransformEventResponse](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              modeldb.TransformEventResponse.decode(_iprot)
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[modeldb.TransformEventResponse], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[modeldb.TransformEventResponse], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRUCT, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              success_item_element.write(_oprot)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              success_item_element.write(_oprot)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readIerExValue(_iprot: TProtocol): modeldb.InvalidExperimentRunException = {
        modeldb.InvalidExperimentRunException.decode(_iprot)
      }
    
      @inline private def writeIerExField(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IerExField)
        writeIerExValue(ierEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIerExValue(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        ierEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[modeldb.TransformEventResponse]],
        val ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[modeldb.TransformEventResponse]] with ThriftStruct
      with _root_.scala.Product3[Option[Seq[modeldb.TransformEventResponse]], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[modeldb.TransformEventResponse]] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        ierEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[modeldb.TransformEventResponse]] = success
      def _2: _root_.scala.Option[modeldb.InvalidExperimentRunException] = ierEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[Seq[modeldb.TransformEventResponse]], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          ierEx,
          svEx
        )
      }
    
      def successField: Option[Seq[modeldb.TransformEventResponse]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(ierEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (ierEx.isDefined) writeIerExField(ierEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[modeldb.TransformEventResponse]] = this.success,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = this.ierEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          ierEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.ierEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "storePipelineTransformEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storePipelineTransformEvent$args = StorePipelineTransformEvent.Args
  type storePipelineTransformEvent$args = StorePipelineTransformEvent.Args

  val storePipelineTransformEvent$result = StorePipelineTransformEvent.Result
  type storePipelineTransformEvent$result = StorePipelineTransformEvent.Result

  object ComputeModelAncestry extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("computeModelAncestry_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int
      ): Args =
        new Args(
          modelId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.modelId)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int
      ) = this(
        modelId,
        Map.empty
      )
    
      def _1: Int = modelId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ModelAncestryResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("computeModelAncestry_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ModelAncestryResponse] = implicitly[Manifest[modeldb.ModelAncestryResponse]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ModelAncestryResponse.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ModelAncestryResponse] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ModelAncestryResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.ModelAncestryResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ModelAncestryResponse = {
        modeldb.ModelAncestryResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ModelAncestryResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ModelAncestryResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ModelAncestryResponse],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ModelAncestryResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.ModelAncestryResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ModelAncestryResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ModelAncestryResponse] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.ModelAncestryResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.ModelAncestryResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ModelAncestryResponse] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "computeModelAncestry"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val computeModelAncestry$args = ComputeModelAncestry.Args
  type computeModelAncestry$args = ComputeModelAncestry.Args

  val computeModelAncestry$result = ComputeModelAncestry.Result
  type computeModelAncestry$result = ComputeModelAncestry.Result

  object ExtractPipeline extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("extractPipeline_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int
      ): Args =
        new Args(
          modelId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.modelId)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int
      ) = this(
        modelId,
        Map.empty
      )
    
      def _1: Int = modelId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ExtractedPipelineResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("extractPipeline_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ExtractedPipelineResponse] = implicitly[Manifest[modeldb.ExtractedPipelineResponse]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ExtractedPipelineResponse.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ExtractedPipelineResponse] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ExtractedPipelineResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.ExtractedPipelineResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ExtractedPipelineResponse = {
        modeldb.ExtractedPipelineResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ExtractedPipelineResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ExtractedPipelineResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ExtractedPipelineResponse],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ExtractedPipelineResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.ExtractedPipelineResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ExtractedPipelineResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ExtractedPipelineResponse] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.ExtractedPipelineResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.ExtractedPipelineResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ExtractedPipelineResponse] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "extractPipeline"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val extractPipeline$args = ExtractPipeline.Args
  type extractPipeline$args = ExtractPipeline.Args

  val extractPipeline$result = ExtractPipeline.Result
  type extractPipeline$result = ExtractPipeline.Result


}
